{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _construct from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/wrapNativeSuper\";\nimport _createForOfIteratorHelper from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\n\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols(source)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return target;\n};\n\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n}; // src/index.ts\n\n\nexport * from \"redux\";\nimport { produce, current as current4, freeze, original as original2, isDraft as isDraft6 } from \"immer\";\nimport { createSelector, createSelectorCreator as createSelectorCreator2, lruMemoize, weakMapMemoize as weakMapMemoize2 } from \"reselect\"; // src/createDraftSafeSelector.ts\n\nimport { current, isDraft } from \"immer\";\nimport { createSelectorCreator, weakMapMemoize } from \"reselect\";\n\nvar createDraftSafeSelectorCreator = function createDraftSafeSelectorCreator() {\n  var createSelector2 = createSelectorCreator.apply(void 0, arguments);\n  var createDraftSafeSelector2 = Object.assign(function () {\n    var selector = createSelector2.apply(void 0, arguments);\n\n    var wrappedSelector = function wrappedSelector(value) {\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n\n      return selector.apply(void 0, [isDraft(value) ? current(value) : value].concat(rest));\n    };\n\n    Object.assign(wrappedSelector, selector);\n    return wrappedSelector;\n  }, {\n    withTypes: function withTypes() {\n      return createDraftSafeSelector2;\n    }\n  });\n  return createDraftSafeSelector2;\n};\n\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(weakMapMemoize); // src/configureStore.ts\n\nimport { applyMiddleware, createStore, compose as compose2, combineReducers, isPlainObject as isPlainObject2 } from \"redux\"; // src/devtoolsExtension.ts\n\nimport { compose } from \"redux\";\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {\n  if (arguments.length === 0) return void 0;\n  if (typeof arguments[0] === \"object\") return compose;\n  return compose.apply(null, arguments);\n};\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function () {\n  return function (noop3) {\n    return noop3;\n  };\n}; // src/getDefaultMiddleware.ts\n\nimport { thunk as thunkMiddleware, withExtraArgument } from \"redux-thunk\"; // src/createAction.ts\n\nimport { isAction } from \"redux\"; // src/tsHelpers.ts\n\nvar hasMatchFunction = function hasMatchFunction(v) {\n  return v && typeof v.match === \"function\";\n}; // src/createAction.ts\n\n\nfunction createAction(type, prepareAction) {\n  function actionCreator() {\n    if (prepareAction) {\n      var prepared = prepareAction.apply(void 0, arguments);\n\n      if (!prepared) {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(0) : \"prepareAction did not return an object\");\n      }\n\n      return __spreadValues(__spreadValues({\n        type: type,\n        payload: prepared.payload\n      }, \"meta\" in prepared && {\n        meta: prepared.meta\n      }), \"error\" in prepared && {\n        error: prepared.error\n      });\n    }\n\n    return {\n      type: type,\n      payload: arguments.length <= 0 ? undefined : arguments[0]\n    };\n  }\n\n  actionCreator.toString = function () {\n    return \"\".concat(type);\n  };\n\n  actionCreator.type = type;\n\n  actionCreator.match = function (action) {\n    return isAction(action) && action.type === type;\n  };\n\n  return actionCreator;\n}\n\nfunction isActionCreator(action) {\n  return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n  hasMatchFunction(action);\n}\n\nfunction isFSA(action) {\n  return isAction(action) && Object.keys(action).every(isValidKey);\n}\n\nfunction isValidKey(key) {\n  return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\n} // src/actionCreatorInvariantMiddleware.ts\n\n\nfunction getMessage(type) {\n  var splitType = type ? \"\".concat(type).split(\"/\") : [];\n  var actionName = splitType[splitType.length - 1] || \"actionCreator\";\n  return \"Detected an action creator with type \\\"\".concat(type || \"unknown\", \"\\\" being dispatched. \\nMake sure you're calling the action creator before dispatching, i.e. `dispatch(\").concat(actionName, \"())` instead of `dispatch(\").concat(actionName, \")`. This is necessary even if the action has no payload.\");\n}\n\nfunction createActionCreatorInvariantMiddleware() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (process.env.NODE_ENV === \"production\") {\n    return function () {\n      return function (next) {\n        return function (action) {\n          return next(action);\n        };\n      };\n    };\n  }\n\n  var _options$isActionCrea = options.isActionCreator,\n      isActionCreator2 = _options$isActionCrea === void 0 ? isActionCreator : _options$isActionCrea;\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (isActionCreator2(action)) {\n          console.warn(getMessage(action.type));\n        }\n\n        return next(action);\n      };\n    };\n  };\n} // src/utils.ts\n\n\nimport { produce as createNextState, isDraftable } from \"immer\";\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n  var elapsed = 0;\n  return {\n    measureTime: function measureTime(fn) {\n      var started = Date.now();\n\n      try {\n        return fn();\n      } finally {\n        var finished = Date.now();\n        elapsed += finished - started;\n      }\n    },\n    warnIfExceeded: function warnIfExceeded() {\n      if (elapsed > maxDelay) {\n        console.warn(\"\".concat(fnName, \" took \").concat(elapsed, \"ms, which is more than the warning threshold of \").concat(maxDelay, \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\"));\n      }\n    }\n  };\n}\n\nfunction find(iterable, comparator) {\n  var _iterator3 = _createForOfIteratorHelper(iterable),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var entry = _step3.value;\n\n      if (comparator(entry)) {\n        return entry;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return void 0;\n}\n\nvar Tuple = /*#__PURE__*/function (_Array) {\n  _inherits(_Tuple, _Array);\n\n  var _super = _createSuper(_Tuple);\n\n  function _Tuple() {\n    var _this;\n\n    _classCallCheck(this, _Tuple);\n\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(items));\n    Object.setPrototypeOf(_assertThisInitialized(_this), _Tuple.prototype);\n    return _this;\n  }\n\n  _createClass(_Tuple, [{\n    key: \"concat\",\n    value: function concat() {\n      for (var _len3 = arguments.length, arr = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        arr[_key3] = arguments[_key3];\n      }\n\n      return _get(_getPrototypeOf(_Tuple.prototype), \"concat\", this).apply(this, arr);\n    }\n  }, {\n    key: \"prepend\",\n    value: function prepend() {\n      for (var _len4 = arguments.length, arr = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        arr[_key4] = arguments[_key4];\n      }\n\n      if (arr.length === 1 && Array.isArray(arr[0])) {\n        return _construct(_Tuple, _toConsumableArray(arr[0].concat(this)));\n      }\n\n      return _construct(_Tuple, _toConsumableArray(arr.concat(this)));\n    }\n  }], [{\n    key: Symbol.species,\n    get: function get() {\n      return _Tuple;\n    }\n  }]);\n\n  return _Tuple;\n}( /*#__PURE__*/_wrapNativeSuper(Array));\n\nfunction freezeDraftable(val) {\n  return isDraftable(val) ? createNextState(val, function () {}) : val;\n}\n\nfunction emplace(map, key, handler) {\n  if (map.has(key)) {\n    var value = map.get(key);\n\n    if (handler.update) {\n      value = handler.update(value, key, map);\n      map.set(key, value);\n    }\n\n    return value;\n  }\n\n  if (!handler.insert) throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(10) : \"No insert provided for key not already in map\");\n  var inserted = handler.insert(key, map);\n  map.set(key, inserted);\n  return inserted;\n} // src/immutableStateInvariantMiddleware.ts\n\n\nfunction isImmutableDefault(value) {\n  return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\n\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n  var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n  return {\n    detectMutations: function detectMutations() {\n      return _detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n    }\n  };\n}\n\nfunction trackProperties(isImmutable) {\n  var ignorePaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var obj = arguments.length > 2 ? arguments[2] : undefined;\n  var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n  var checkedObjects = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : /* @__PURE__ */new Set();\n  var tracked = {\n    value: obj\n  };\n\n  if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n    checkedObjects.add(obj);\n    tracked.children = {};\n\n    for (var key in obj) {\n      var childPath = path ? path + \".\" + key : key;\n\n      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n        continue;\n      }\n\n      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n    }\n  }\n\n  return tracked;\n}\n\nfunction _detectMutations(isImmutable) {\n  var ignoredPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var trackedProperty = arguments.length > 2 ? arguments[2] : undefined;\n  var obj = arguments.length > 3 ? arguments[3] : undefined;\n  var sameParentRef = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var path = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n  var prevObj = trackedProperty ? trackedProperty.value : void 0;\n  var sameRef = prevObj === obj;\n\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n    return {\n      wasMutated: true,\n      path: path\n    };\n  }\n\n  if (isImmutable(prevObj) || isImmutable(obj)) {\n    return {\n      wasMutated: false\n    };\n  }\n\n  var keysToDetect = {};\n\n  for (var key in trackedProperty.children) {\n    keysToDetect[key] = true;\n  }\n\n  for (var _key5 in obj) {\n    keysToDetect[_key5] = true;\n  }\n\n  var hasIgnoredPaths = ignoredPaths.length > 0;\n\n  var _loop = function _loop(_key6) {\n    var nestedPath = path ? path + \".\" + _key6 : _key6;\n\n    if (hasIgnoredPaths) {\n      var hasMatches = ignoredPaths.some(function (ignored) {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n\n        return nestedPath === ignored;\n      });\n\n      if (hasMatches) {\n        return \"continue\";\n      }\n    }\n\n    var result = _detectMutations(isImmutable, ignoredPaths, trackedProperty.children[_key6], obj[_key6], sameRef, nestedPath);\n\n    if (result.wasMutated) {\n      return {\n        v: result\n      };\n    }\n  };\n\n  for (var _key6 in keysToDetect) {\n    var _ret = _loop(_key6);\n\n    if (_ret === \"continue\") continue;\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return {\n    wasMutated: false\n  };\n}\n\nfunction createImmutableStateInvariantMiddleware() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (process.env.NODE_ENV === \"production\") {\n    return function () {\n      return function (next) {\n        return function (action) {\n          return next(action);\n        };\n      };\n    };\n  } else {\n    var stringify2 = function stringify2(obj, serializer, indent, decycler) {\n      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n    },\n        getSerialize2 = function getSerialize2(serializer, decycler) {\n      var stack = [],\n          keys = [];\n      if (!decycler) decycler = function decycler(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n      };\n      return function (key, value) {\n        if (stack.length > 0) {\n          var thisPos = stack.indexOf(this);\n          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n          if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n\n        return serializer == null ? value : serializer.call(this, key, value);\n      };\n    };\n\n    var stringify = stringify2,\n        getSerialize = getSerialize2;\n    var _options$isImmutable = options.isImmutable,\n        isImmutable = _options$isImmutable === void 0 ? isImmutableDefault : _options$isImmutable,\n        ignoredPaths = options.ignoredPaths,\n        _options$warnAfter = options.warnAfter,\n        warnAfter = _options$warnAfter === void 0 ? 32 : _options$warnAfter;\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return function (_ref) {\n      var getState = _ref.getState;\n      var state = getState();\n      var tracker = track(state);\n      var result;\n      return function (next) {\n        return function (action) {\n          var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n          measureUtils.measureTime(function () {\n            state = getState();\n            result = tracker.detectMutations();\n            tracker = track(state);\n\n            if (result.wasMutated) {\n              throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(19) : \"A state mutation was detected between dispatches, in the path '\".concat(result.path || \"\", \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\"));\n            }\n          });\n          var dispatchedAction = next(action);\n          measureUtils.measureTime(function () {\n            state = getState();\n            result = tracker.detectMutations();\n            tracker = track(state);\n\n            if (result.wasMutated) {\n              throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(20) : \"A state mutation was detected inside a dispatch, in the path: \".concat(result.path || \"\", \". Take a look at the reducer(s) handling the action \").concat(stringify2(action), \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\"));\n            }\n          });\n          measureUtils.warnIfExceeded();\n          return dispatchedAction;\n        };\n      };\n    };\n  }\n} // src/serializableStateInvariantMiddleware.ts\n\n\nimport { isAction as isAction2, isPlainObject } from \"redux\";\n\nfunction isPlain(val) {\n  var type = typeof val;\n  return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || isPlainObject(val);\n}\n\nfunction findNonSerializableValue(value) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var isSerializable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isPlain;\n  var getEntries = arguments.length > 3 ? arguments[3] : undefined;\n  var ignoredPaths = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var cache = arguments.length > 5 ? arguments[5] : undefined;\n  var foundNestedSerializable;\n\n  if (!isSerializable(value)) {\n    return {\n      keyPath: path || \"<root>\",\n      value: value\n    };\n  }\n\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  if (cache == null ? void 0 : cache.has(value)) return false;\n  var entries = getEntries != null ? getEntries(value) : Object.entries(value);\n  var hasIgnoredPaths = ignoredPaths.length > 0;\n\n  var _iterator4 = _createForOfIteratorHelper(entries),\n      _step4;\n\n  try {\n    var _loop2 = function _loop2() {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n          key = _step4$value[0],\n          nestedValue = _step4$value[1];\n\n      var nestedPath = path ? path + \".\" + key : key;\n\n      if (hasIgnoredPaths) {\n        var hasMatches = ignoredPaths.some(function (ignored) {\n          if (ignored instanceof RegExp) {\n            return ignored.test(nestedPath);\n          }\n\n          return nestedPath === ignored;\n        });\n\n        if (hasMatches) {\n          return \"continue\";\n        }\n      }\n\n      if (!isSerializable(nestedValue)) {\n        return {\n          v: {\n            keyPath: nestedPath,\n            value: nestedValue\n          }\n        };\n      }\n\n      if (typeof nestedValue === \"object\") {\n        foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n\n        if (foundNestedSerializable) {\n          return {\n            v: foundNestedSerializable\n          };\n        }\n      }\n    };\n\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _ret2 = _loop2();\n\n      if (_ret2 === \"continue\") continue;\n      if (typeof _ret2 === \"object\") return _ret2.v;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  if (cache && isNestedFrozen(value)) cache.add(value);\n  return false;\n}\n\nfunction isNestedFrozen(value) {\n  if (!Object.isFrozen(value)) return false;\n\n  for (var _i = 0, _Object$values = Object.values(value); _i < _Object$values.length; _i++) {\n    var nestedValue = _Object$values[_i];\n    if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n    if (!isNestedFrozen(nestedValue)) return false;\n  }\n\n  return true;\n}\n\nfunction createSerializableStateInvariantMiddleware() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (process.env.NODE_ENV === \"production\") {\n    return function () {\n      return function (next) {\n        return function (action) {\n          return next(action);\n        };\n      };\n    };\n  } else {\n    var _options$isSerializab = options.isSerializable,\n        isSerializable = _options$isSerializab === void 0 ? isPlain : _options$isSerializab,\n        getEntries = options.getEntries,\n        _options$ignoredActio = options.ignoredActions,\n        ignoredActions = _options$ignoredActio === void 0 ? [] : _options$ignoredActio,\n        _options$ignoredActio2 = options.ignoredActionPaths,\n        ignoredActionPaths = _options$ignoredActio2 === void 0 ? [\"meta.arg\", \"meta.baseQueryMeta\"] : _options$ignoredActio2,\n        _options$ignoredPaths = options.ignoredPaths,\n        ignoredPaths = _options$ignoredPaths === void 0 ? [] : _options$ignoredPaths,\n        _options$warnAfter2 = options.warnAfter,\n        warnAfter = _options$warnAfter2 === void 0 ? 32 : _options$warnAfter2,\n        _options$ignoreState = options.ignoreState,\n        ignoreState = _options$ignoreState === void 0 ? false : _options$ignoreState,\n        _options$ignoreAction = options.ignoreActions,\n        ignoreActions = _options$ignoreAction === void 0 ? false : _options$ignoreAction,\n        _options$disableCache = options.disableCache,\n        disableCache = _options$disableCache === void 0 ? false : _options$disableCache;\n    var cache = !disableCache && WeakSet ? /* @__PURE__ */new WeakSet() : void 0;\n    return function (storeAPI) {\n      return function (next) {\n        return function (action) {\n          if (!isAction2(action)) {\n            return next(action);\n          }\n\n          var result = next(action);\n          var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n\n          if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n            measureUtils.measureTime(function () {\n              var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n\n              if (foundActionNonSerializableValue) {\n                var keyPath = foundActionNonSerializableValue.keyPath,\n                    value = foundActionNonSerializableValue.value;\n                console.error(\"A non-serializable value was detected in an action, in the path: `\".concat(keyPath, \"`. Value:\"), value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n              }\n            });\n          }\n\n          if (!ignoreState) {\n            measureUtils.measureTime(function () {\n              var state = storeAPI.getState();\n              var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n\n              if (foundStateNonSerializableValue) {\n                var keyPath = foundStateNonSerializableValue.keyPath,\n                    value = foundStateNonSerializableValue.value;\n                console.error(\"A non-serializable value was detected in the state, in the path: `\".concat(keyPath, \"`. Value:\"), value, \"\\nTake a look at the reducer(s) handling this action type: \".concat(action.type, \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\"));\n              }\n            });\n            measureUtils.warnIfExceeded();\n          }\n\n          return result;\n        };\n      };\n    };\n  }\n} // src/getDefaultMiddleware.ts\n\n\nfunction isBoolean(x) {\n  return typeof x === \"boolean\";\n}\n\nvar buildGetDefaultMiddleware = function buildGetDefaultMiddleware() {\n  return function getDefaultMiddleware(options) {\n    var _ref2 = options != null ? options : {},\n        _ref2$thunk = _ref2.thunk,\n        thunk = _ref2$thunk === void 0 ? true : _ref2$thunk,\n        _ref2$immutableCheck = _ref2.immutableCheck,\n        immutableCheck = _ref2$immutableCheck === void 0 ? true : _ref2$immutableCheck,\n        _ref2$serializableChe = _ref2.serializableCheck,\n        serializableCheck = _ref2$serializableChe === void 0 ? true : _ref2$serializableChe,\n        _ref2$actionCreatorCh = _ref2.actionCreatorCheck,\n        actionCreatorCheck = _ref2$actionCreatorCh === void 0 ? true : _ref2$actionCreatorCh;\n\n    var middlewareArray = new Tuple();\n\n    if (thunk) {\n      if (isBoolean(thunk)) {\n        middlewareArray.push(thunkMiddleware);\n      } else {\n        middlewareArray.push(withExtraArgument(thunk.extraArgument));\n      }\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (immutableCheck) {\n        var immutableOptions = {};\n\n        if (!isBoolean(immutableCheck)) {\n          immutableOptions = immutableCheck;\n        }\n\n        middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n      }\n\n      if (serializableCheck) {\n        var serializableOptions = {};\n\n        if (!isBoolean(serializableCheck)) {\n          serializableOptions = serializableCheck;\n        }\n\n        middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n      }\n\n      if (actionCreatorCheck) {\n        var actionCreatorOptions = {};\n\n        if (!isBoolean(actionCreatorCheck)) {\n          actionCreatorOptions = actionCreatorCheck;\n        }\n\n        middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n      }\n    }\n\n    return middlewareArray;\n  };\n}; // src/autoBatchEnhancer.ts\n\n\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\n\nvar prepareAutoBatched = function prepareAutoBatched() {\n  return function (payload) {\n    return {\n      payload: payload,\n      meta: {\n        [SHOULD_AUTOBATCH]: true\n      }\n    };\n  };\n};\n\nvar createQueueWithTimer = function createQueueWithTimer(timeout) {\n  return function (notify) {\n    setTimeout(notify, timeout);\n  };\n};\n\nvar rAF = typeof window !== \"undefined\" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);\n\nvar autoBatchEnhancer = function autoBatchEnhancer() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    type: \"raf\"\n  };\n  return function (next) {\n    return function () {\n      var store = next.apply(void 0, arguments);\n      var notifying = true;\n      var shouldNotifyAtEndOfTick = false;\n      var notificationQueued = false;\n      var listeners = /* @__PURE__ */new Set();\n      var queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n\n      var notifyListeners = function notifyListeners() {\n        notificationQueued = false;\n\n        if (shouldNotifyAtEndOfTick) {\n          shouldNotifyAtEndOfTick = false;\n          listeners.forEach(function (l) {\n            return l();\n          });\n        }\n      };\n\n      return Object.assign({}, store, {\n        // Override the base `store.subscribe` method to keep original listeners\n        // from running if we're delaying notifications\n        subscribe: function subscribe(listener2) {\n          var wrappedListener = function wrappedListener() {\n            return notifying && listener2();\n          };\n\n          var unsubscribe = store.subscribe(wrappedListener);\n          listeners.add(listener2);\n          return function () {\n            unsubscribe();\n            listeners.delete(listener2);\n          };\n        },\n        // Override the base `store.dispatch` method so that we can check actions\n        // for the `shouldAutoBatch` flag and determine if batching is active\n        dispatch: function dispatch(action) {\n          var _a;\n\n          try {\n            notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);\n            shouldNotifyAtEndOfTick = !notifying;\n\n            if (shouldNotifyAtEndOfTick) {\n              if (!notificationQueued) {\n                notificationQueued = true;\n                queueCallback(notifyListeners);\n              }\n            }\n\n            return store.dispatch(action);\n          } finally {\n            notifying = true;\n          }\n        }\n      });\n    };\n  };\n}; // src/getDefaultEnhancers.ts\n\n\nvar buildGetDefaultEnhancers = function buildGetDefaultEnhancers(middlewareEnhancer) {\n  return function getDefaultEnhancers(options) {\n    var _ref3 = options != null ? options : {},\n        _ref3$autoBatch = _ref3.autoBatch,\n        autoBatch = _ref3$autoBatch === void 0 ? true : _ref3$autoBatch;\n\n    var enhancerArray = new Tuple(middlewareEnhancer);\n\n    if (autoBatch) {\n      enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n    }\n\n    return enhancerArray;\n  };\n}; // src/configureStore.ts\n\n\nvar IS_PRODUCTION = process.env.NODE_ENV === \"production\";\n\nfunction configureStore(options) {\n  var getDefaultMiddleware = buildGetDefaultMiddleware();\n\n  var _ref4 = options || {},\n      _ref4$reducer = _ref4.reducer,\n      reducer = _ref4$reducer === void 0 ? void 0 : _ref4$reducer,\n      middleware = _ref4.middleware,\n      _ref4$devTools = _ref4.devTools,\n      devTools = _ref4$devTools === void 0 ? true : _ref4$devTools,\n      _ref4$preloadedState = _ref4.preloadedState,\n      preloadedState = _ref4$preloadedState === void 0 ? void 0 : _ref4$preloadedState,\n      _ref4$enhancers = _ref4.enhancers,\n      enhancers = _ref4$enhancers === void 0 ? void 0 : _ref4$enhancers;\n\n  var rootReducer;\n\n  if (typeof reducer === \"function\") {\n    rootReducer = reducer;\n  } else if (isPlainObject2(reducer)) {\n    rootReducer = combineReducers(reducer);\n  } else {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(1) : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n  }\n\n  if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(2) : \"`middleware` field must be a callback\");\n  }\n\n  var finalMiddleware;\n\n  if (typeof middleware === \"function\") {\n    finalMiddleware = middleware(getDefaultMiddleware);\n\n    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(3) : \"when using a middleware builder function, an array of middleware must be returned\");\n    }\n  } else {\n    finalMiddleware = getDefaultMiddleware();\n  }\n\n  if (!IS_PRODUCTION && finalMiddleware.some(function (item) {\n    return typeof item !== \"function\";\n  })) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(4) : \"each middleware provided to configureStore must be a function\");\n  }\n\n  var finalCompose = compose2;\n\n  if (devTools) {\n    finalCompose = composeWithDevTools(__spreadValues({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: !IS_PRODUCTION\n    }, typeof devTools === \"object\" && devTools));\n  }\n\n  var middlewareEnhancer = applyMiddleware.apply(void 0, _toConsumableArray(finalMiddleware));\n  var getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n\n  if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(5) : \"`enhancers` field must be a callback\");\n  }\n\n  var storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n\n  if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(6) : \"`enhancers` callback must return an array\");\n  }\n\n  if (!IS_PRODUCTION && storeEnhancers.some(function (item) {\n    return typeof item !== \"function\";\n  })) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(7) : \"each enhancer provided to configureStore must be a function\");\n  }\n\n  if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n    console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n  }\n\n  var composedEnhancer = finalCompose.apply(void 0, _toConsumableArray(storeEnhancers));\n  return createStore(rootReducer, preloadedState, composedEnhancer);\n} // src/createReducer.ts\n\n\nimport { produce as createNextState2, isDraft as isDraft2, isDraftable as isDraftable2 } from \"immer\"; // src/mapBuilders.ts\n\nfunction executeReducerBuilderCallback(builderCallback) {\n  var actionsMap = {};\n  var actionMatchers = [];\n  var defaultCaseReducer;\n  var builder = {\n    addCase: function addCase(typeOrActionCreator, reducer) {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (actionMatchers.length > 0) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(26) : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n        }\n\n        if (defaultCaseReducer) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(27) : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n\n      var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n\n      if (!type) {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(28) : \"`builder.addCase` cannot be called with an empty action type\");\n      }\n\n      if (type in actionsMap) {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(29) : \"`builder.addCase` cannot be called with two reducers for the same action type '\".concat(type, \"'\"));\n      }\n\n      actionsMap[type] = reducer;\n      return builder;\n    },\n    addMatcher: function addMatcher(matcher, reducer) {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (defaultCaseReducer) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(30) : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n\n      actionMatchers.push({\n        matcher: matcher,\n        reducer: reducer\n      });\n      return builder;\n    },\n    addDefaultCase: function addDefaultCase(reducer) {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (defaultCaseReducer) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(31) : \"`builder.addDefaultCase` can only be called once\");\n        }\n      }\n\n      defaultCaseReducer = reducer;\n      return builder;\n    }\n  };\n  builderCallback(builder);\n  return [actionsMap, actionMatchers, defaultCaseReducer];\n} // src/createReducer.ts\n\n\nfunction isStateFunction(x) {\n  return typeof x === \"function\";\n}\n\nfunction createReducer(initialState, mapOrBuilderCallback) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof mapOrBuilderCallback === \"object\") {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(8) : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n    }\n  }\n\n  var _executeReducerBuilde = executeReducerBuilderCallback(mapOrBuilderCallback),\n      _executeReducerBuilde2 = _slicedToArray(_executeReducerBuilde, 3),\n      actionsMap = _executeReducerBuilde2[0],\n      finalActionMatchers = _executeReducerBuilde2[1],\n      finalDefaultCaseReducer = _executeReducerBuilde2[2];\n\n  var getInitialState;\n\n  if (isStateFunction(initialState)) {\n    getInitialState = function getInitialState() {\n      return freezeDraftable(initialState());\n    };\n  } else {\n    var frozenInitialState = freezeDraftable(initialState);\n\n    getInitialState = function getInitialState() {\n      return frozenInitialState;\n    };\n  }\n\n  function reducer() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getInitialState();\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n    var caseReducers = [actionsMap[action.type]].concat(_toConsumableArray(finalActionMatchers.filter(function (_ref5) {\n      var matcher = _ref5.matcher;\n      return matcher(action);\n    }).map(function (_ref6) {\n      var reducer2 = _ref6.reducer;\n      return reducer2;\n    })));\n\n    if (caseReducers.filter(function (cr) {\n      return !!cr;\n    }).length === 0) {\n      caseReducers = [finalDefaultCaseReducer];\n    }\n\n    return caseReducers.reduce(function (previousState, caseReducer) {\n      if (caseReducer) {\n        if (isDraft2(previousState)) {\n          var draft = previousState;\n          var result = caseReducer(draft, action);\n\n          if (result === void 0) {\n            return previousState;\n          }\n\n          return result;\n        } else if (!isDraftable2(previousState)) {\n          var _result = caseReducer(previousState, action);\n\n          if (_result === void 0) {\n            if (previousState === null) {\n              return previousState;\n            }\n\n            throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(9) : \"A case reducer on a non-draftable value must not return undefined\");\n          }\n\n          return _result;\n        } else {\n          return createNextState2(previousState, function (draft) {\n            return caseReducer(draft, action);\n          });\n        }\n      }\n\n      return previousState;\n    }, state);\n  }\n\n  reducer.getInitialState = getInitialState;\n  return reducer;\n} // src/nanoid.ts\n\n\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\n\nvar nanoid = function nanoid() {\n  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;\n  var id = \"\";\n  var i = size;\n\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n\n  return id;\n}; // src/matchers.ts\n\n\nvar matches = function matches(matcher, action) {\n  if (hasMatchFunction(matcher)) {\n    return matcher.match(action);\n  } else {\n    return matcher(action);\n  }\n};\n\nfunction isAnyOf() {\n  for (var _len5 = arguments.length, matchers = new Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {\n    matchers[_key7] = arguments[_key7];\n  }\n\n  return function (action) {\n    return matchers.some(function (matcher) {\n      return matches(matcher, action);\n    });\n  };\n}\n\nfunction isAllOf() {\n  for (var _len6 = arguments.length, matchers = new Array(_len6), _key8 = 0; _key8 < _len6; _key8++) {\n    matchers[_key8] = arguments[_key8];\n  }\n\n  return function (action) {\n    return matchers.every(function (matcher) {\n      return matches(matcher, action);\n    });\n  };\n}\n\nfunction hasExpectedRequestMetadata(action, validStatus) {\n  if (!action || !action.meta) return false;\n  var hasValidRequestId = typeof action.meta.requestId === \"string\";\n  var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n  return hasValidRequestId && hasValidRequestStatus;\n}\n\nfunction isAsyncThunkArray(a) {\n  return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\n\nfunction isPending() {\n  for (var _len7 = arguments.length, asyncThunks = new Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {\n    asyncThunks[_key9] = arguments[_key9];\n  }\n\n  if (asyncThunks.length === 0) {\n    return function (action) {\n      return hasExpectedRequestMetadata(action, [\"pending\"]);\n    };\n  }\n\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isPending()(asyncThunks[0]);\n  }\n\n  return isAnyOf.apply(void 0, _toConsumableArray(asyncThunks.map(function (asyncThunk) {\n    return asyncThunk.pending;\n  })));\n}\n\nfunction isRejected() {\n  for (var _len8 = arguments.length, asyncThunks = new Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {\n    asyncThunks[_key10] = arguments[_key10];\n  }\n\n  if (asyncThunks.length === 0) {\n    return function (action) {\n      return hasExpectedRequestMetadata(action, [\"rejected\"]);\n    };\n  }\n\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejected()(asyncThunks[0]);\n  }\n\n  return isAnyOf.apply(void 0, _toConsumableArray(asyncThunks.map(function (asyncThunk) {\n    return asyncThunk.rejected;\n  })));\n}\n\nfunction isRejectedWithValue() {\n  var hasFlag = function hasFlag(action) {\n    return action && action.meta && action.meta.rejectedWithValue;\n  };\n\n  for (var _len9 = arguments.length, asyncThunks = new Array(_len9), _key11 = 0; _key11 < _len9; _key11++) {\n    asyncThunks[_key11] = arguments[_key11];\n  }\n\n  if (asyncThunks.length === 0) {\n    return isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n  }\n\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejectedWithValue()(asyncThunks[0]);\n  }\n\n  return isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n}\n\nfunction isFulfilled() {\n  for (var _len10 = arguments.length, asyncThunks = new Array(_len10), _key12 = 0; _key12 < _len10; _key12++) {\n    asyncThunks[_key12] = arguments[_key12];\n  }\n\n  if (asyncThunks.length === 0) {\n    return function (action) {\n      return hasExpectedRequestMetadata(action, [\"fulfilled\"]);\n    };\n  }\n\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isFulfilled()(asyncThunks[0]);\n  }\n\n  return isAnyOf.apply(void 0, _toConsumableArray(asyncThunks.map(function (asyncThunk) {\n    return asyncThunk.fulfilled;\n  })));\n}\n\nfunction isAsyncThunkAction() {\n  for (var _len11 = arguments.length, asyncThunks = new Array(_len11), _key13 = 0; _key13 < _len11; _key13++) {\n    asyncThunks[_key13] = arguments[_key13];\n  }\n\n  if (asyncThunks.length === 0) {\n    return function (action) {\n      return hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]);\n    };\n  }\n\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isAsyncThunkAction()(asyncThunks[0]);\n  }\n\n  return isAnyOf.apply(void 0, _toConsumableArray(asyncThunks.flatMap(function (asyncThunk) {\n    return [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled];\n  })));\n} // src/createAsyncThunk.ts\n\n\nvar commonProperties = [\"name\", \"message\", \"stack\", \"code\"];\n\nvar RejectWithValue = function RejectWithValue(payload, meta) {\n  _classCallCheck(this, RejectWithValue);\n\n  this.payload = payload;\n  this.meta = meta;\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n\n  __publicField(this, \"_type\");\n};\n\nvar FulfillWithMeta = function FulfillWithMeta(payload, meta) {\n  _classCallCheck(this, FulfillWithMeta);\n\n  this.payload = payload;\n  this.meta = meta;\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n\n  __publicField(this, \"_type\");\n};\n\nvar miniSerializeError = function miniSerializeError(value) {\n  if (typeof value === \"object\" && value !== null) {\n    var simpleError = {};\n\n    var _iterator5 = _createForOfIteratorHelper(commonProperties),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var property = _step5.value;\n\n        if (typeof value[property] === \"string\") {\n          simpleError[property] = value[property];\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    return simpleError;\n  }\n\n  return {\n    message: String(value)\n  };\n};\n\nvar createAsyncThunk = /* @__PURE__ */function () {\n  function createAsyncThunk2(typePrefix, payloadCreator, options) {\n    var fulfilled = createAction(typePrefix + \"/fulfilled\", function (payload, requestId, arg, meta) {\n      return {\n        payload: payload,\n        meta: __spreadProps(__spreadValues({}, meta || {}), {\n          arg: arg,\n          requestId: requestId,\n          requestStatus: \"fulfilled\"\n        })\n      };\n    });\n    var pending = createAction(typePrefix + \"/pending\", function (requestId, arg, meta) {\n      return {\n        payload: void 0,\n        meta: __spreadProps(__spreadValues({}, meta || {}), {\n          arg: arg,\n          requestId: requestId,\n          requestStatus: \"pending\"\n        })\n      };\n    });\n    var rejected = createAction(typePrefix + \"/rejected\", function (error, requestId, arg, payload, meta) {\n      return {\n        payload: payload,\n        error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n        meta: __spreadProps(__spreadValues({}, meta || {}), {\n          arg: arg,\n          requestId: requestId,\n          rejectedWithValue: !!payload,\n          requestStatus: \"rejected\",\n          aborted: (error == null ? void 0 : error.name) === \"AbortError\",\n          condition: (error == null ? void 0 : error.name) === \"ConditionError\"\n        })\n      };\n    });\n\n    function actionCreator(arg) {\n      return function (dispatch, getState, extra) {\n        var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n        var abortController = new AbortController();\n        var abortHandler;\n        var abortReason;\n\n        function abort(reason) {\n          abortReason = reason;\n          abortController.abort();\n        }\n\n        var promise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var _a, _b, finalAction, conditionResult, abortedPromise, skipDispatch;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {\n                    getState: getState,\n                    extra: extra\n                  });\n\n                  if (!isThenable(conditionResult)) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  _context.next = 5;\n                  return conditionResult;\n\n                case 5:\n                  conditionResult = _context.sent;\n\n                case 6:\n                  if (!(conditionResult === false || abortController.signal.aborted)) {\n                    _context.next = 8;\n                    break;\n                  }\n\n                  throw {\n                    name: \"ConditionError\",\n                    message: \"Aborted due to condition callback returning false.\"\n                  };\n\n                case 8:\n                  abortedPromise = new Promise(function (_, reject) {\n                    abortHandler = function abortHandler() {\n                      reject({\n                        name: \"AbortError\",\n                        message: abortReason || \"Aborted\"\n                      });\n                    };\n\n                    abortController.signal.addEventListener(\"abort\", abortHandler);\n                  });\n                  dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {\n                    requestId: requestId,\n                    arg: arg\n                  }, {\n                    getState: getState,\n                    extra: extra\n                  })));\n                  _context.next = 12;\n                  return Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {\n                    dispatch: dispatch,\n                    getState: getState,\n                    extra: extra,\n                    requestId: requestId,\n                    signal: abortController.signal,\n                    abort: abort,\n                    rejectWithValue: function rejectWithValue(value, meta) {\n                      return new RejectWithValue(value, meta);\n                    },\n                    fulfillWithValue: function fulfillWithValue(value, meta) {\n                      return new FulfillWithMeta(value, meta);\n                    }\n                  })).then(function (result) {\n                    if (result instanceof RejectWithValue) {\n                      throw result;\n                    }\n\n                    if (result instanceof FulfillWithMeta) {\n                      return fulfilled(result.payload, requestId, arg, result.meta);\n                    }\n\n                    return fulfilled(result, requestId, arg);\n                  })]);\n\n                case 12:\n                  finalAction = _context.sent;\n                  _context.next = 18;\n                  break;\n\n                case 15:\n                  _context.prev = 15;\n                  _context.t0 = _context[\"catch\"](0);\n                  finalAction = _context.t0 instanceof RejectWithValue ? rejected(null, requestId, arg, _context.t0.payload, _context.t0.meta) : rejected(_context.t0, requestId, arg);\n\n                case 18:\n                  _context.prev = 18;\n\n                  if (abortHandler) {\n                    abortController.signal.removeEventListener(\"abort\", abortHandler);\n                  }\n\n                  return _context.finish(18);\n\n                case 21:\n                  skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n\n                  if (!skipDispatch) {\n                    dispatch(finalAction);\n                  }\n\n                  return _context.abrupt(\"return\", finalAction);\n\n                case 24:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 15, 18, 21]]);\n        }))();\n\n        return Object.assign(promise, {\n          abort: abort,\n          requestId: requestId,\n          arg: arg,\n          unwrap: function unwrap() {\n            return promise.then(unwrapResult);\n          }\n        });\n      };\n    }\n\n    return Object.assign(actionCreator, {\n      pending: pending,\n      rejected: rejected,\n      fulfilled: fulfilled,\n      settled: isAnyOf(rejected, fulfilled),\n      typePrefix: typePrefix\n    });\n  }\n\n  createAsyncThunk2.withTypes = function () {\n    return createAsyncThunk2;\n  };\n\n  return createAsyncThunk2;\n}();\n\nfunction unwrapResult(action) {\n  if (action.meta && action.meta.rejectedWithValue) {\n    throw action.payload;\n  }\n\n  if (action.error) {\n    throw action.error;\n  }\n\n  return action.payload;\n}\n\nfunction isThenable(value) {\n  return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n} // src/createSlice.ts\n\n\nvar asyncThunkSymbol = /* @__PURE__ */Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n  [asyncThunkSymbol]: createAsyncThunk\n};\n\nvar ReducerType = /* @__PURE__ */function (ReducerType2) {\n  ReducerType2[\"reducer\"] = \"reducer\";\n  ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n  ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n  return ReducerType2;\n}(ReducerType || {});\n\nfunction getType(slice, actionKey) {\n  return \"\".concat(slice, \"/\").concat(actionKey);\n}\n\nfunction buildCreateSlice() {\n  var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      creators = _ref8.creators;\n\n  var _a;\n\n  var cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];\n  return function createSlice2(options) {\n    var name = options.name,\n        _options$reducerPath = options.reducerPath,\n        reducerPath = _options$reducerPath === void 0 ? name : _options$reducerPath;\n\n    if (!name) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(11) : \"`name` is a required option for createSlice\");\n    }\n\n    if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n      if (options.initialState === void 0) {\n        console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n      }\n    }\n\n    var reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n    var reducerNames = Object.keys(reducers);\n    var context = {\n      sliceCaseReducersByName: {},\n      sliceCaseReducersByType: {},\n      actionCreators: {},\n      sliceMatchers: []\n    };\n    var contextMethods = {\n      addCase: function addCase(typeOrActionCreator, reducer2) {\n        var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n\n        if (!type) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(12) : \"`context.addCase` cannot be called with an empty action type\");\n        }\n\n        if (type in context.sliceCaseReducersByType) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(13) : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n        }\n\n        context.sliceCaseReducersByType[type] = reducer2;\n        return contextMethods;\n      },\n      addMatcher: function addMatcher(matcher, reducer2) {\n        context.sliceMatchers.push({\n          matcher: matcher,\n          reducer: reducer2\n        });\n        return contextMethods;\n      },\n      exposeAction: function exposeAction(name2, actionCreator) {\n        context.actionCreators[name2] = actionCreator;\n        return contextMethods;\n      },\n      exposeCaseReducer: function exposeCaseReducer(name2, reducer2) {\n        context.sliceCaseReducersByName[name2] = reducer2;\n        return contextMethods;\n      }\n    };\n    reducerNames.forEach(function (reducerName) {\n      var reducerDefinition = reducers[reducerName];\n      var reducerDetails = {\n        reducerName: reducerName,\n        type: getType(name, reducerName),\n        createNotation: typeof options.reducers === \"function\"\n      };\n\n      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n      } else {\n        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n      }\n    });\n\n    function buildReducer() {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (typeof options.extraReducers === \"object\") {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(14) : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n        }\n      }\n\n      var _ref9 = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers],\n          _ref10 = _slicedToArray(_ref9, 3),\n          _ref10$ = _ref10[0],\n          extraReducers = _ref10$ === void 0 ? {} : _ref10$,\n          _ref10$2 = _ref10[1],\n          actionMatchers = _ref10$2 === void 0 ? [] : _ref10$2,\n          _ref10$3 = _ref10[2],\n          defaultCaseReducer = _ref10$3 === void 0 ? void 0 : _ref10$3;\n\n      var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), context.sliceCaseReducersByType);\n\n      return createReducer(options.initialState, function (builder) {\n        for (var key in finalCaseReducers) {\n          builder.addCase(key, finalCaseReducers[key]);\n        }\n\n        var _iterator6 = _createForOfIteratorHelper(context.sliceMatchers),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var sM = _step6.value;\n            builder.addMatcher(sM.matcher, sM.reducer);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        var _iterator7 = _createForOfIteratorHelper(actionMatchers),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var m = _step7.value;\n            builder.addMatcher(m.matcher, m.reducer);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        if (defaultCaseReducer) {\n          builder.addDefaultCase(defaultCaseReducer);\n        }\n      });\n    }\n\n    var selectSelf = function selectSelf(state) {\n      return state;\n    };\n\n    var injectedSelectorCache = /* @__PURE__ */new Map();\n\n    var _reducer;\n\n    function reducer(state, action) {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer(state, action);\n    }\n\n    function getInitialState() {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer.getInitialState();\n    }\n\n    function makeSelectorProps(reducerPath2) {\n      var injected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      function selectSlice(state) {\n        var sliceState = state[reducerPath2];\n\n        if (typeof sliceState === \"undefined\") {\n          if (injected) {\n            sliceState = getInitialState();\n          } else if (process.env.NODE_ENV !== \"production\") {\n            throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(15) : \"selectSlice returned undefined for an uninjected slice reducer\");\n          }\n        }\n\n        return sliceState;\n      }\n\n      function getSelectors() {\n        var selectState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : selectSelf;\n        var selectorCache = emplace(injectedSelectorCache, injected, {\n          insert: function insert() {\n            return /* @__PURE__ */new WeakMap();\n          }\n        });\n        return emplace(selectorCache, selectState, {\n          insert: function insert() {\n            var _a2;\n\n            var map = {};\n\n            for (var _i2 = 0, _Object$entries = Object.entries((_a2 = options.selectors) != null ? _a2 : {}); _i2 < _Object$entries.length; _i2++) {\n              var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n                  name2 = _Object$entries$_i[0],\n                  selector = _Object$entries$_i[1];\n\n              map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n            }\n\n            return map;\n          }\n        });\n      }\n\n      return {\n        reducerPath: reducerPath2,\n        getSelectors: getSelectors,\n\n        get selectors() {\n          return getSelectors(selectSlice);\n        },\n\n        selectSlice: selectSlice\n      };\n    }\n\n    var slice = __spreadProps(__spreadValues({\n      name: name,\n      reducer: reducer,\n      actions: context.actionCreators,\n      caseReducers: context.sliceCaseReducersByName,\n      getInitialState: getInitialState\n    }, makeSelectorProps(reducerPath)), {\n      injectInto: function injectInto(injectable) {\n        var _a2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var _b = _a2,\n            pathOpt = _b.reducerPath,\n            config = __objRest(_b, [\"reducerPath\"]);\n\n        var newReducerPath = pathOpt != null ? pathOpt : reducerPath;\n        injectable.inject({\n          reducerPath: newReducerPath,\n          reducer: reducer\n        }, config);\n        return __spreadValues(__spreadValues({}, slice), makeSelectorProps(newReducerPath, true));\n      }\n    });\n\n    return slice;\n  };\n}\n\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n  function wrapper(rootState) {\n    var sliceState = selectState(rootState);\n\n    if (typeof sliceState === \"undefined\") {\n      if (injected) {\n        sliceState = getInitialState();\n      } else if (process.env.NODE_ENV !== \"production\") {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(16) : \"selectState returned undefined for an uninjected slice reducer\");\n      }\n    }\n\n    for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key14 = 1; _key14 < _len12; _key14++) {\n      args[_key14 - 1] = arguments[_key14];\n    }\n\n    return selector.apply(void 0, [sliceState].concat(args));\n  }\n\n  wrapper.unwrapped = selector;\n  return wrapper;\n}\n\nvar createSlice = /* @__PURE__ */buildCreateSlice();\n\nfunction buildReducerCreators() {\n  function asyncThunk(payloadCreator, config) {\n    return __spreadValues({\n      _reducerDefinitionType: \"asyncThunk\"\n      /* asyncThunk */\n      ,\n      payloadCreator: payloadCreator\n    }, config);\n  }\n\n  asyncThunk.withTypes = function () {\n    return asyncThunk;\n  };\n\n  return {\n    reducer: function reducer(caseReducer) {\n      return Object.assign({\n        // hack so the wrapping function has the same name as the original\n        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n        [caseReducer.name]: function () {\n          return caseReducer.apply(void 0, arguments);\n        }\n      }[caseReducer.name], {\n        _reducerDefinitionType: \"reducer\"\n        /* reducer */\n\n      });\n    },\n    preparedReducer: function preparedReducer(prepare, reducer) {\n      return {\n        _reducerDefinitionType: \"reducerWithPrepare\"\n        /* reducerWithPrepare */\n        ,\n        prepare: prepare,\n        reducer: reducer\n      };\n    },\n    asyncThunk: asyncThunk\n  };\n}\n\nfunction handleNormalReducerDefinition(_ref11, maybeReducerWithPrepare, context) {\n  var type = _ref11.type,\n      reducerName = _ref11.reducerName,\n      createNotation = _ref11.createNotation;\n  var caseReducer;\n  var prepareCallback;\n\n  if (\"reducer\" in maybeReducerWithPrepare) {\n    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(17) : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n    }\n\n    caseReducer = maybeReducerWithPrepare.reducer;\n    prepareCallback = maybeReducerWithPrepare.prepare;\n  } else {\n    caseReducer = maybeReducerWithPrepare;\n  }\n\n  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\n\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"asyncThunk\"\n  /* asyncThunk */\n  ;\n}\n\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\"\n  /* reducerWithPrepare */\n  ;\n}\n\nfunction handleThunkCaseReducerDefinition(_ref12, reducerDefinition, context, cAT) {\n  var type = _ref12.type,\n      reducerName = _ref12.reducerName;\n\n  if (!cAT) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(18) : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n  }\n\n  var payloadCreator = reducerDefinition.payloadCreator,\n      fulfilled = reducerDefinition.fulfilled,\n      pending = reducerDefinition.pending,\n      rejected = reducerDefinition.rejected,\n      settled = reducerDefinition.settled,\n      options = reducerDefinition.options;\n  var thunk = cAT(type, payloadCreator, options);\n  context.exposeAction(reducerName, thunk);\n\n  if (fulfilled) {\n    context.addCase(thunk.fulfilled, fulfilled);\n  }\n\n  if (pending) {\n    context.addCase(thunk.pending, pending);\n  }\n\n  if (rejected) {\n    context.addCase(thunk.rejected, rejected);\n  }\n\n  if (settled) {\n    context.addMatcher(thunk.settled, settled);\n  }\n\n  context.exposeCaseReducer(reducerName, {\n    fulfilled: fulfilled || noop,\n    pending: pending || noop,\n    rejected: rejected || noop,\n    settled: settled || noop\n  });\n}\n\nfunction noop() {} // src/entities/entity_state.ts\n\n\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\n\nfunction createInitialStateFactory(stateAdapter) {\n  function getInitialState() {\n    var additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var entities = arguments.length > 1 ? arguments[1] : undefined;\n    var state = Object.assign(getInitialEntityState(), additionalState);\n    return entities ? stateAdapter.setAll(state, entities) : state;\n  }\n\n  return {\n    getInitialState: getInitialState\n  };\n} // src/entities/state_selectors.ts\n\n\nfunction createSelectorsFactory() {\n  function getSelectors(selectState) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$createSelect = options.createSelector,\n        createSelector2 = _options$createSelect === void 0 ? createDraftSafeSelector : _options$createSelect;\n\n    var selectIds = function selectIds(state) {\n      return state.ids;\n    };\n\n    var selectEntities = function selectEntities(state) {\n      return state.entities;\n    };\n\n    var selectAll = createSelector2(selectIds, selectEntities, function (ids, entities) {\n      return ids.map(function (id) {\n        return entities[id];\n      });\n    });\n\n    var selectId = function selectId(_, id) {\n      return id;\n    };\n\n    var selectById = function selectById(entities, id) {\n      return entities[id];\n    };\n\n    var selectTotal = createSelector2(selectIds, function (ids) {\n      return ids.length;\n    });\n\n    if (!selectState) {\n      return {\n        selectIds: selectIds,\n        selectEntities: selectEntities,\n        selectAll: selectAll,\n        selectTotal: selectTotal,\n        selectById: createSelector2(selectEntities, selectId, selectById)\n      };\n    }\n\n    var selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n    return {\n      selectIds: createSelector2(selectState, selectIds),\n      selectEntities: selectGlobalizedEntities,\n      selectAll: createSelector2(selectState, selectAll),\n      selectTotal: createSelector2(selectState, selectTotal),\n      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n    };\n  }\n\n  return {\n    getSelectors: getSelectors\n  };\n} // src/entities/sorted_state_adapter.ts\n\n\nimport { current as current3 } from \"immer\"; // src/entities/state_adapter.ts\n\nimport { produce as createNextState3, isDraft as isDraft3 } from \"immer\";\nvar isDraftTyped = isDraft3;\n\nfunction createSingleArgumentStateOperator(mutator) {\n  var operator = createStateOperator(function (_, state) {\n    return mutator(state);\n  });\n  return function operation(state) {\n    return operator(state, void 0);\n  };\n}\n\nfunction createStateOperator(mutator) {\n  return function operation(state, arg) {\n    function isPayloadActionArgument(arg2) {\n      return isFSA(arg2);\n    }\n\n    var runMutator = function runMutator(draft) {\n      if (isPayloadActionArgument(arg)) {\n        mutator(arg.payload, draft);\n      } else {\n        mutator(arg, draft);\n      }\n    };\n\n    if (isDraftTyped(state)) {\n      runMutator(state);\n      return state;\n    }\n\n    return createNextState3(state, runMutator);\n  };\n} // src/entities/utils.ts\n\n\nimport { current as current2, isDraft as isDraft4 } from \"immer\";\n\nfunction selectIdValue(entity, selectId) {\n  var key = selectId(entity);\n\n  if (process.env.NODE_ENV !== \"production\" && key === void 0) {\n    console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n  }\n\n  return key;\n}\n\nfunction ensureEntitiesArray(entities) {\n  if (!Array.isArray(entities)) {\n    entities = Object.values(entities);\n  }\n\n  return entities;\n}\n\nfunction getCurrent(value) {\n  return isDraft4(value) ? current2(value) : value;\n}\n\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n  newEntities = ensureEntitiesArray(newEntities);\n  var existingIdsArray = getCurrent(state.ids);\n  var existingIds = new Set(existingIdsArray);\n  var added = [];\n  var updated = [];\n\n  var _iterator8 = _createForOfIteratorHelper(newEntities),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var entity = _step8.value;\n      var id = selectIdValue(entity, selectId);\n\n      if (existingIds.has(id)) {\n        updated.push({\n          id: id,\n          changes: entity\n        });\n      } else {\n        added.push(entity);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return [added, updated, existingIdsArray];\n} // src/entities/unsorted_state_adapter.ts\n\n\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    var key = selectIdValue(entity, selectId);\n\n    if (key in state.entities) {\n      return;\n    }\n\n    state.ids.push(key);\n    state.entities[key] = entity;\n  }\n\n  function addManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n\n    var _iterator9 = _createForOfIteratorHelper(newEntities),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var entity = _step9.value;\n        addOneMutably(entity, state);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n\n  function setOneMutably(entity, state) {\n    var key = selectIdValue(entity, selectId);\n\n    if (!(key in state.entities)) {\n      state.ids.push(key);\n    }\n\n    ;\n    state.entities[key] = entity;\n  }\n\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n\n    var _iterator10 = _createForOfIteratorHelper(newEntities),\n        _step10;\n\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var entity = _step10.value;\n        setOneMutably(entity, state);\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n  }\n\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(newEntities, state);\n  }\n\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n\n  function removeManyMutably(keys, state) {\n    var didMutate = false;\n    keys.forEach(function (key) {\n      if (key in state.entities) {\n        delete state.entities[key];\n        didMutate = true;\n      }\n    });\n\n    if (didMutate) {\n      state.ids = state.ids.filter(function (id) {\n        return id in state.entities;\n      });\n    }\n  }\n\n  function removeAllMutably(state) {\n    Object.assign(state, {\n      ids: [],\n      entities: {}\n    });\n  }\n\n  function takeNewKey(keys, update, state) {\n    var original3 = state.entities[update.id];\n\n    if (original3 === void 0) {\n      return false;\n    }\n\n    var updated = Object.assign({}, original3, update.changes);\n    var newKey = selectIdValue(updated, selectId);\n    var hasNewKey = newKey !== update.id;\n\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n\n    ;\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n\n  function updateManyMutably(updates, state) {\n    var newKeys = {};\n    var updatesPerEntity = {};\n    updates.forEach(function (update) {\n      if (update.id in state.entities) {\n        updatesPerEntity[update.id] = {\n          id: update.id,\n          // Spreads ignore falsy values, so this works even if there isn't\n          // an existing update already at this key\n          changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\n        };\n      }\n    });\n    updates = Object.values(updatesPerEntity);\n    var didMutateEntities = updates.length > 0;\n\n    if (didMutateEntities) {\n      var didMutateIds = updates.filter(function (update) {\n        return takeNewKey(newKeys, update, state);\n      }).length > 0;\n\n      if (didMutateIds) {\n        state.ids = Object.values(state.entities).map(function (e) {\n          return selectIdValue(e, selectId);\n        });\n      }\n    }\n  }\n\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n\n  function upsertManyMutably(newEntities, state) {\n    var _splitAddedUpdatedEnt = splitAddedUpdatedEntities(newEntities, selectId, state),\n        _splitAddedUpdatedEnt2 = _slicedToArray(_splitAddedUpdatedEnt, 2),\n        added = _splitAddedUpdatedEnt2[0],\n        updated = _splitAddedUpdatedEnt2[1];\n\n    updateManyMutably(updated, state);\n    addManyMutably(added, state);\n  }\n\n  return {\n    removeAll: createSingleArgumentStateOperator(removeAllMutably),\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably)\n  };\n} // src/entities/sorted_state_adapter.ts\n\n\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\n  var lowIndex = 0;\n  var highIndex = sortedItems.length;\n\n  while (lowIndex < highIndex) {\n    var middleIndex = lowIndex + highIndex >>> 1;\n    var currentItem = sortedItems[middleIndex];\n    var res = comparisonFunction(item, currentItem);\n\n    if (res >= 0) {\n      lowIndex = middleIndex + 1;\n    } else {\n      highIndex = middleIndex;\n    }\n  }\n\n  return lowIndex;\n}\n\nfunction insert(sortedItems, item, comparisonFunction) {\n  var insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\n  sortedItems.splice(insertAtIndex, 0, item);\n  return sortedItems;\n}\n\nfunction createSortedStateAdapter(selectId, comparer) {\n  var _createUnsortedStateA = createUnsortedStateAdapter(selectId),\n      removeOne = _createUnsortedStateA.removeOne,\n      removeMany = _createUnsortedStateA.removeMany,\n      removeAll = _createUnsortedStateA.removeAll;\n\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n\n  function addManyMutably(newEntities, state, existingIds) {\n    newEntities = ensureEntitiesArray(newEntities);\n    var existingKeys = new Set(existingIds != null ? existingIds : current3(state.ids));\n    var models = newEntities.filter(function (model) {\n      return !existingKeys.has(selectIdValue(model, selectId));\n    });\n\n    if (models.length !== 0) {\n      mergeFunction(state, models);\n    }\n  }\n\n  function setOneMutably(entity, state) {\n    return setManyMutably([entity], state);\n  }\n\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n\n    if (newEntities.length !== 0) {\n      var _iterator11 = _createForOfIteratorHelper(newEntities),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var item = _step11.value;\n          delete state.entities[selectId(item)];\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      mergeFunction(state, newEntities);\n    }\n  }\n\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(newEntities, state, []);\n  }\n\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n\n  function updateManyMutably(updates, state) {\n    var appliedUpdates = false;\n    var replacedIds = false;\n\n    var _iterator12 = _createForOfIteratorHelper(updates),\n        _step12;\n\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var update = _step12.value;\n        var entity = state.entities[update.id];\n\n        if (!entity) {\n          continue;\n        }\n\n        appliedUpdates = true;\n        Object.assign(entity, update.changes);\n        var newId = selectId(entity);\n\n        if (update.id !== newId) {\n          replacedIds = true;\n          delete state.entities[update.id];\n          var oldIndex = state.ids.indexOf(update.id);\n          state.ids[oldIndex] = newId;\n          state.entities[newId] = entity;\n        }\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n\n    if (appliedUpdates) {\n      mergeFunction(state, [], appliedUpdates, replacedIds);\n    }\n  }\n\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n\n  function upsertManyMutably(newEntities, state) {\n    var _splitAddedUpdatedEnt3 = splitAddedUpdatedEntities(newEntities, selectId, state),\n        _splitAddedUpdatedEnt4 = _slicedToArray(_splitAddedUpdatedEnt3, 3),\n        added = _splitAddedUpdatedEnt4[0],\n        updated = _splitAddedUpdatedEnt4[1],\n        existingIdsArray = _splitAddedUpdatedEnt4[2];\n\n    if (updated.length) {\n      updateManyMutably(updated, state);\n    }\n\n    if (added.length) {\n      addManyMutably(added, state, existingIdsArray);\n    }\n  }\n\n  function areArraysEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length && i < b.length; i++) {\n      if (a[i] === b[i]) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  var mergeInsertion = function mergeInsertion(state, addedItems, appliedUpdates, replacedIds) {\n    var currentEntities = getCurrent(state.entities);\n    var currentIds = getCurrent(state.ids);\n    var stateEntities = state.entities;\n    var ids = currentIds;\n\n    if (replacedIds) {\n      ids = Array.from(new Set(currentIds));\n    }\n\n    var sortedEntities = [];\n\n    var _iterator13 = _createForOfIteratorHelper(ids),\n        _step13;\n\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var id = _step13.value;\n        var entity = currentEntities[id];\n\n        if (entity) {\n          sortedEntities.push(entity);\n        }\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n\n    var wasPreviouslyEmpty = sortedEntities.length === 0;\n\n    var _iterator14 = _createForOfIteratorHelper(addedItems),\n        _step14;\n\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var item = _step14.value;\n        stateEntities[selectId(item)] = item;\n\n        if (!wasPreviouslyEmpty) {\n          insert(sortedEntities, item, comparer);\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n\n    if (wasPreviouslyEmpty) {\n      sortedEntities = addedItems.slice().sort(comparer);\n    } else if (appliedUpdates) {\n      sortedEntities.sort(comparer);\n    }\n\n    var newSortedIds = sortedEntities.map(selectId);\n\n    if (!areArraysEqual(currentIds, newSortedIds)) {\n      state.ids = newSortedIds;\n    }\n  };\n\n  var mergeFunction = mergeInsertion;\n  return {\n    removeOne: removeOne,\n    removeMany: removeMany,\n    removeAll: removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably)\n  };\n} // src/entities/create_adapter.ts\n\n\nfunction createEntityAdapter() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _spreadValues = __spreadValues({\n    sortComparer: false,\n    selectId: function selectId(instance) {\n      return instance.id;\n    }\n  }, options),\n      selectId = _spreadValues.selectId,\n      sortComparer = _spreadValues.sortComparer;\n\n  var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  var stateFactory = createInitialStateFactory(stateAdapter);\n  var selectorsFactory = createSelectorsFactory();\n  return __spreadValues(__spreadValues(__spreadValues({\n    selectId: selectId,\n    sortComparer: sortComparer\n  }, stateFactory), selectorsFactory), stateAdapter);\n} // src/listenerMiddleware/index.ts\n\n\nimport { isAction as isAction3 } from \"redux\"; // src/listenerMiddleware/exceptions.ts\n\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\".concat(cancelled);\nvar taskCompleted = \"task-\".concat(completed);\nvar listenerCancelled = \"\".concat(listener, \"-\").concat(cancelled);\nvar listenerCompleted = \"\".concat(listener, \"-\").concat(completed);\n\nvar TaskAbortError = function TaskAbortError(code) {\n  _classCallCheck(this, TaskAbortError);\n\n  this.code = code;\n\n  __publicField(this, \"name\", \"TaskAbortError\");\n\n  __publicField(this, \"message\");\n\n  this.message = \"\".concat(task, \" \").concat(cancelled, \" (reason: \").concat(code, \")\");\n}; // src/listenerMiddleware/utils.ts\n\n\nvar assertFunction = function assertFunction(func, expected) {\n  if (typeof func !== \"function\") {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(32) : \"\".concat(expected, \" is not a function\"));\n  }\n};\n\nvar noop2 = function noop2() {};\n\nvar catchRejection = function catchRejection(promise) {\n  var onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop2;\n  promise.catch(onError);\n  return promise;\n};\n\nvar addAbortSignalListener = function addAbortSignalListener(abortSignal, callback) {\n  abortSignal.addEventListener(\"abort\", callback, {\n    once: true\n  });\n  return function () {\n    return abortSignal.removeEventListener(\"abort\", callback);\n  };\n};\n\nvar abortControllerWithReason = function abortControllerWithReason(abortController, reason) {\n  var signal = abortController.signal;\n\n  if (signal.aborted) {\n    return;\n  }\n\n  if (!(\"reason\" in signal)) {\n    Object.defineProperty(signal, \"reason\", {\n      enumerable: true,\n      value: reason,\n      configurable: true,\n      writable: true\n    });\n  }\n\n  ;\n  abortController.abort(reason);\n}; // src/listenerMiddleware/task.ts\n\n\nvar validateActive = function validateActive(signal) {\n  if (signal.aborted) {\n    var reason = signal.reason;\n    throw new TaskAbortError(reason);\n  }\n};\n\nfunction raceWithSignal(signal, promise) {\n  var cleanup = noop2;\n  return new Promise(function (resolve, reject) {\n    var notifyRejection = function notifyRejection() {\n      return reject(new TaskAbortError(signal.reason));\n    };\n\n    if (signal.aborted) {\n      notifyRejection();\n      return;\n    }\n\n    cleanup = addAbortSignalListener(signal, notifyRejection);\n    promise.finally(function () {\n      return cleanup();\n    }).then(resolve, reject);\n  }).finally(function () {\n    cleanup = noop2;\n  });\n}\n\nvar runTask = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(task2, cleanUp) {\n    var value;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return Promise.resolve();\n\n          case 3:\n            _context2.next = 5;\n            return task2();\n\n          case 5:\n            value = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              status: \"ok\",\n              value: value\n            });\n\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2[\"catch\"](0);\n            return _context2.abrupt(\"return\", {\n              status: _context2.t0 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n              error: _context2.t0\n            });\n\n          case 12:\n            _context2.prev = 12;\n            cleanUp == null ? void 0 : cleanUp();\n            return _context2.finish(12);\n\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 9, 12, 15]]);\n  }));\n\n  return function runTask(_x, _x2) {\n    return _ref13.apply(this, arguments);\n  };\n}();\n\nvar createPause = function createPause(signal) {\n  return function (promise) {\n    return catchRejection(raceWithSignal(signal, promise).then(function (output) {\n      validateActive(signal);\n      return output;\n    }));\n  };\n};\n\nvar createDelay = function createDelay(signal) {\n  var pause = createPause(signal);\n  return function (timeoutMs) {\n    return pause(new Promise(function (resolve) {\n      return setTimeout(resolve, timeoutMs);\n    }));\n  };\n}; // src/listenerMiddleware/index.ts\n\n\nvar assign = Object.assign;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\n\nvar createFork = function createFork(parentAbortSignal, parentBlockingPromises) {\n  var linkControllers = function linkControllers(controller) {\n    return addAbortSignalListener(parentAbortSignal, function () {\n      return abortControllerWithReason(controller, parentAbortSignal.reason);\n    });\n  };\n\n  return function (taskExecutor, opts) {\n    assertFunction(taskExecutor, \"taskExecutor\");\n    var childAbortController = new AbortController();\n    linkControllers(childAbortController);\n    var result = runTask( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var result2;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              validateActive(parentAbortSignal);\n              validateActive(childAbortController.signal);\n              _context3.next = 4;\n              return taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n              });\n\n            case 4:\n              result2 = _context3.sent;\n              validateActive(childAbortController.signal);\n              return _context3.abrupt(\"return\", result2);\n\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    })), function () {\n      return abortControllerWithReason(childAbortController, taskCompleted);\n    });\n\n    if (opts == null ? void 0 : opts.autoJoin) {\n      parentBlockingPromises.push(result.catch(noop2));\n    }\n\n    return {\n      result: createPause(parentAbortSignal)(result),\n      cancel: function cancel() {\n        abortControllerWithReason(childAbortController, taskCancelled);\n      }\n    };\n  };\n};\n\nvar createTakePattern = function createTakePattern(startListening, signal) {\n  var take = /*#__PURE__*/function () {\n    var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(predicate, timeout) {\n      var unsubscribe, tuplePromise, promises, output;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              validateActive(signal);\n\n              unsubscribe = function unsubscribe() {};\n\n              tuplePromise = new Promise(function (resolve, reject) {\n                var stopListening = startListening({\n                  predicate: predicate,\n                  effect: function effect(action, listenerApi) {\n                    listenerApi.unsubscribe();\n                    resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);\n                  }\n                });\n\n                unsubscribe = function unsubscribe() {\n                  stopListening();\n                  reject();\n                };\n              });\n              promises = [tuplePromise];\n\n              if (timeout != null) {\n                promises.push(new Promise(function (resolve) {\n                  return setTimeout(resolve, timeout, null);\n                }));\n              }\n\n              _context4.prev = 5;\n              _context4.next = 8;\n              return raceWithSignal(signal, Promise.race(promises));\n\n            case 8:\n              output = _context4.sent;\n              validateActive(signal);\n              return _context4.abrupt(\"return\", output);\n\n            case 11:\n              _context4.prev = 11;\n              unsubscribe();\n              return _context4.finish(11);\n\n            case 14:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[5,, 11, 14]]);\n    }));\n\n    return function take(_x3, _x4) {\n      return _ref15.apply(this, arguments);\n    };\n  }();\n\n  return function (predicate, timeout) {\n    return catchRejection(take(predicate, timeout));\n  };\n};\n\nvar getListenerEntryPropsFrom = function getListenerEntryPropsFrom(options) {\n  var type = options.type,\n      actionCreator = options.actionCreator,\n      matcher = options.matcher,\n      predicate = options.predicate,\n      effect = options.effect;\n\n  if (type) {\n    predicate = createAction(type).match;\n  } else if (actionCreator) {\n    type = actionCreator.type;\n    predicate = actionCreator.match;\n  } else if (matcher) {\n    predicate = matcher;\n  } else if (predicate) {} else {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(21) : \"Creating or removing a listener requires one of the known fields for matching an action\");\n  }\n\n  assertFunction(effect, \"options.listener\");\n  return {\n    predicate: predicate,\n    type: type,\n    effect: effect\n  };\n};\n\nvar createListenerEntry = Object.assign(function (options) {\n  var _getListenerEntryProp = getListenerEntryPropsFrom(options),\n      type = _getListenerEntryProp.type,\n      predicate = _getListenerEntryProp.predicate,\n      effect = _getListenerEntryProp.effect;\n\n  var id = nanoid();\n  var entry = {\n    id: id,\n    effect: effect,\n    type: type,\n    predicate: predicate,\n    pending: /* @__PURE__ */new Set(),\n    unsubscribe: function unsubscribe() {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(22) : \"Unsubscribe not initialized\");\n    }\n  };\n  return entry;\n}, {\n  withTypes: function withTypes() {\n    return createListenerEntry;\n  }\n});\n\nvar cancelActiveListeners = function cancelActiveListeners(entry) {\n  entry.pending.forEach(function (controller) {\n    abortControllerWithReason(controller, listenerCancelled);\n  });\n};\n\nvar createClearListenerMiddleware = function createClearListenerMiddleware(listenerMap) {\n  return function () {\n    listenerMap.forEach(cancelActiveListeners);\n    listenerMap.clear();\n  };\n};\n\nvar safelyNotifyError = function safelyNotifyError(errorHandler, errorToNotify, errorInfo) {\n  try {\n    errorHandler(errorToNotify, errorInfo);\n  } catch (errorHandlerError) {\n    setTimeout(function () {\n      throw errorHandlerError;\n    }, 0);\n  }\n};\n\nvar addListener = Object.assign(createAction(\"\".concat(alm, \"/add\")), {\n  withTypes: function withTypes() {\n    return addListener;\n  }\n});\nvar clearAllListeners = createAction(\"\".concat(alm, \"/removeAll\"));\nvar removeListener = Object.assign(createAction(\"\".concat(alm, \"/remove\")), {\n  withTypes: function withTypes() {\n    return removeListener;\n  }\n});\n\nvar defaultErrorHandler = function defaultErrorHandler() {\n  var _console;\n\n  for (var _len13 = arguments.length, args = new Array(_len13), _key15 = 0; _key15 < _len13; _key15++) {\n    args[_key15] = arguments[_key15];\n  }\n\n  (_console = console).error.apply(_console, [\"\".concat(alm, \"/error\")].concat(args));\n};\n\nvar createListenerMiddleware = function createListenerMiddleware() {\n  var middlewareOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var listenerMap = /* @__PURE__ */new Map();\n  var extra = middlewareOptions.extra,\n      _middlewareOptions$on = middlewareOptions.onError,\n      onError = _middlewareOptions$on === void 0 ? defaultErrorHandler : _middlewareOptions$on;\n  assertFunction(onError, \"onError\");\n\n  var insertEntry = function insertEntry(entry) {\n    entry.unsubscribe = function () {\n      return listenerMap.delete(entry.id);\n    };\n\n    listenerMap.set(entry.id, entry);\n    return function (cancelOptions) {\n      entry.unsubscribe();\n\n      if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    };\n  };\n\n  var startListening = function startListening(options) {\n    var entry = find(Array.from(listenerMap.values()), function (existingEntry) {\n      return existingEntry.effect === options.effect;\n    });\n\n    if (!entry) {\n      entry = createListenerEntry(options);\n    }\n\n    return insertEntry(entry);\n  };\n\n  Object.assign(startListening, {\n    withTypes: function withTypes() {\n      return startListening;\n    }\n  });\n\n  var stopListening = function stopListening(options) {\n    var _getListenerEntryProp2 = getListenerEntryPropsFrom(options),\n        type = _getListenerEntryProp2.type,\n        effect = _getListenerEntryProp2.effect,\n        predicate = _getListenerEntryProp2.predicate;\n\n    var entry = find(Array.from(listenerMap.values()), function (entry2) {\n      var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n      return matchPredicateOrType && entry2.effect === effect;\n    });\n\n    if (entry) {\n      entry.unsubscribe();\n\n      if (options.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    }\n\n    return !!entry;\n  };\n\n  Object.assign(stopListening, {\n    withTypes: function withTypes() {\n      return stopListening;\n    }\n  });\n\n  var notifyListener = /*#__PURE__*/function () {\n    var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(entry, action, api, getOriginalState) {\n      var internalTaskController, take, autoJoinPromises;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              internalTaskController = new AbortController();\n              take = createTakePattern(startListening, internalTaskController.signal);\n              autoJoinPromises = [];\n              _context5.prev = 3;\n              entry.pending.add(internalTaskController);\n              _context5.next = 7;\n              return Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n              assign({}, api, {\n                getOriginalState: getOriginalState,\n                condition: function condition(predicate, timeout) {\n                  return take(predicate, timeout).then(Boolean);\n                },\n                take: take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra: extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: function subscribe() {\n                  listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: function cancelActiveListeners() {\n                  entry.pending.forEach(function (controller, _, set) {\n                    if (controller !== internalTaskController) {\n                      abortControllerWithReason(controller, listenerCancelled);\n                      set.delete(controller);\n                    }\n                  });\n                },\n                cancel: function cancel() {\n                  abortControllerWithReason(internalTaskController, listenerCancelled);\n                  entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: function throwIfCancelled() {\n                  validateActive(internalTaskController.signal);\n                }\n              })));\n\n            case 7:\n              _context5.next = 12;\n              break;\n\n            case 9:\n              _context5.prev = 9;\n              _context5.t0 = _context5[\"catch\"](3);\n\n              if (!(_context5.t0 instanceof TaskAbortError)) {\n                safelyNotifyError(onError, _context5.t0, {\n                  raisedBy: \"effect\"\n                });\n              }\n\n            case 12:\n              _context5.prev = 12;\n              _context5.next = 15;\n              return Promise.all(autoJoinPromises);\n\n            case 15:\n              abortControllerWithReason(internalTaskController, listenerCompleted);\n              entry.pending.delete(internalTaskController);\n              return _context5.finish(12);\n\n            case 18:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, null, [[3, 9, 12, 18]]);\n    }));\n\n    return function notifyListener(_x5, _x6, _x7, _x8) {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n\n  var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n\n  var middleware = function middleware(api) {\n    return function (next) {\n      return function (action) {\n        if (!isAction3(action)) {\n          return next(action);\n        }\n\n        if (addListener.match(action)) {\n          return startListening(action.payload);\n        }\n\n        if (clearAllListeners.match(action)) {\n          clearListenerMiddleware();\n          return;\n        }\n\n        if (removeListener.match(action)) {\n          return stopListening(action.payload);\n        }\n\n        var originalState = api.getState();\n\n        var getOriginalState = function getOriginalState() {\n          if (originalState === INTERNAL_NIL_TOKEN) {\n            throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(23) : \"\".concat(alm, \": getOriginalState can only be called synchronously\"));\n          }\n\n          return originalState;\n        };\n\n        var result;\n\n        try {\n          result = next(action);\n\n          if (listenerMap.size > 0) {\n            var currentState = api.getState();\n            var listenerEntries = Array.from(listenerMap.values());\n\n            for (var _i3 = 0, _listenerEntries = listenerEntries; _i3 < _listenerEntries.length; _i3++) {\n              var entry = _listenerEntries[_i3];\n              var runListener = false;\n\n              try {\n                runListener = entry.predicate(action, currentState, originalState);\n              } catch (predicateError) {\n                runListener = false;\n                safelyNotifyError(onError, predicateError, {\n                  raisedBy: \"predicate\"\n                });\n              }\n\n              if (!runListener) {\n                continue;\n              }\n\n              notifyListener(entry, action, api, getOriginalState);\n            }\n          }\n        } finally {\n          originalState = INTERNAL_NIL_TOKEN;\n        }\n\n        return result;\n      };\n    };\n  };\n\n  return {\n    middleware: middleware,\n    startListening: startListening,\n    stopListening: stopListening,\n    clearListeners: clearListenerMiddleware\n  };\n}; // src/dynamicMiddleware/index.ts\n\n\nimport { compose as compose3 } from \"redux\";\n\nvar createMiddlewareEntry = function createMiddlewareEntry(middleware) {\n  return {\n    id: nanoid(),\n    middleware: middleware,\n    applied: /* @__PURE__ */new Map()\n  };\n};\n\nvar matchInstance = function matchInstance(instanceId) {\n  return function (action) {\n    var _a;\n\n    return ((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.instanceId) === instanceId;\n  };\n};\n\nvar createDynamicMiddleware = function createDynamicMiddleware() {\n  var instanceId = nanoid();\n  var middlewareMap = /* @__PURE__ */new Map();\n  var withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", function () {\n    for (var _len14 = arguments.length, middlewares = new Array(_len14), _key16 = 0; _key16 < _len14; _key16++) {\n      middlewares[_key16] = arguments[_key16];\n    }\n\n    return {\n      payload: middlewares,\n      meta: {\n        instanceId: instanceId\n      }\n    };\n  }), {\n    withTypes: function withTypes() {\n      return withMiddleware;\n    }\n  });\n  var addMiddleware = Object.assign(function addMiddleware2() {\n    for (var _len15 = arguments.length, middlewares = new Array(_len15), _key17 = 0; _key17 < _len15; _key17++) {\n      middlewares[_key17] = arguments[_key17];\n    }\n\n    middlewares.forEach(function (middleware2) {\n      var entry = find(Array.from(middlewareMap.values()), function (entry2) {\n        return entry2.middleware === middleware2;\n      });\n\n      if (!entry) {\n        entry = createMiddlewareEntry(middleware2);\n      }\n\n      middlewareMap.set(entry.id, entry);\n    });\n  }, {\n    withTypes: function withTypes() {\n      return addMiddleware;\n    }\n  });\n\n  var getFinalMiddleware = function getFinalMiddleware(api) {\n    var appliedMiddleware = Array.from(middlewareMap.values()).map(function (entry) {\n      return emplace(entry.applied, api, {\n        insert: function insert() {\n          return entry.middleware(api);\n        }\n      });\n    });\n    return compose3.apply(void 0, _toConsumableArray(appliedMiddleware));\n  };\n\n  var isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n\n  var middleware = function middleware(api) {\n    return function (next) {\n      return function (action) {\n        if (isWithMiddleware(action)) {\n          addMiddleware.apply(void 0, _toConsumableArray(action.payload));\n          return api.dispatch;\n        }\n\n        return getFinalMiddleware(api)(next)(action);\n      };\n    };\n  };\n\n  return {\n    middleware: middleware,\n    addMiddleware: addMiddleware,\n    withMiddleware: withMiddleware,\n    instanceId: instanceId\n  };\n}; // src/combineSlices.ts\n\n\nimport { combineReducers as combineReducers2 } from \"redux\";\n\nvar isSliceLike = function isSliceLike(maybeSliceLike) {\n  return \"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\n};\n\nvar getReducers = function getReducers(slices) {\n  return slices.flatMap(function (sliceOrMap) {\n    return isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap);\n  });\n};\n\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\n\nvar isStateProxy = function isStateProxy(value) {\n  return !!value && !!value[ORIGINAL_STATE];\n};\n\nvar stateProxyMap = /* @__PURE__ */new WeakMap();\n\nvar createStateProxy = function createStateProxy(state, reducerMap) {\n  return emplace(stateProxyMap, state, {\n    insert: function insert() {\n      return new Proxy(state, {\n        get: function get(target, prop, receiver) {\n          if (prop === ORIGINAL_STATE) return target;\n          var result = Reflect.get(target, prop, receiver);\n\n          if (typeof result === \"undefined\") {\n            var reducer = reducerMap[prop.toString()];\n\n            if (reducer) {\n              var reducerResult = reducer(void 0, {\n                type: nanoid()\n              });\n\n              if (typeof reducerResult === \"undefined\") {\n                throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(24) : \"The slice reducer for key \\\"\".concat(prop.toString(), \"\\\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.\"));\n              }\n\n              return reducerResult;\n            }\n          }\n\n          return result;\n        }\n      });\n    }\n  });\n};\n\nvar original = function original(state) {\n  if (!isStateProxy(state)) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(25) : \"original must be used on state Proxy\");\n  }\n\n  return state[ORIGINAL_STATE];\n};\n\nvar noopReducer = function noopReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return state;\n};\n\nfunction combineSlices() {\n  for (var _len16 = arguments.length, slices = new Array(_len16), _key18 = 0; _key18 < _len16; _key18++) {\n    slices[_key18] = arguments[_key18];\n  }\n\n  var reducerMap = Object.fromEntries(getReducers(slices));\n\n  var getReducer = function getReducer() {\n    return Object.keys(reducerMap).length ? combineReducers2(reducerMap) : noopReducer;\n  };\n\n  var reducer = getReducer();\n\n  function combinedReducer(state, action) {\n    return reducer(state, action);\n  }\n\n  combinedReducer.withLazyLoadedSlices = function () {\n    return combinedReducer;\n  };\n\n  var inject = function inject(slice) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var reducerPath = slice.reducerPath,\n        reducerToInject = slice.reducer;\n    var currentReducer = reducerMap[reducerPath];\n\n    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n      if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n        console.error(\"called `inject` to override already-existing reducer \".concat(reducerPath, \" without specifying `overrideExisting: true`\"));\n      }\n\n      return combinedReducer;\n    }\n\n    reducerMap[reducerPath] = reducerToInject;\n    reducer = getReducer();\n    return combinedReducer;\n  };\n\n  var selector = Object.assign(function makeSelector(selectorFn, selectState) {\n    return function selector2(state) {\n      for (var _len17 = arguments.length, args = new Array(_len17 > 1 ? _len17 - 1 : 0), _key19 = 1; _key19 < _len17; _key19++) {\n        args[_key19 - 1] = arguments[_key19];\n      }\n\n      return selectorFn.apply(void 0, [createStateProxy(selectState ? selectState.apply(void 0, [state].concat(args)) : state, reducerMap)].concat(args));\n    };\n  }, {\n    original: original\n  });\n  return Object.assign(combinedReducer, {\n    inject: inject,\n    selector: selector\n  });\n} // src/formatProdErrorMessage.ts\n\n\nfunction formatProdErrorMessage(code) {\n  return \"Minified Redux Toolkit error #\".concat(code, \"; visit https://redux-toolkit.js.org/Errors?code=\").concat(code, \" for the full message or use the non-minified dev environment for full errors. \");\n}\n\nexport { ReducerType, SHOULD_AUTOBATCH, TaskAbortError, Tuple, addListener, asyncThunkCreator, autoBatchEnhancer, buildCreateSlice, clearAllListeners, combineSlices, configureStore, createAction, createActionCreatorInvariantMiddleware, createAsyncThunk, createDraftSafeSelector, createDraftSafeSelectorCreator, createDynamicMiddleware, createEntityAdapter, createImmutableStateInvariantMiddleware, createListenerMiddleware, produce as createNextState, createReducer, createSelector, createSelectorCreator2 as createSelectorCreator, createSerializableStateInvariantMiddleware, createSlice, current4 as current, findNonSerializableValue, formatProdErrorMessage, freeze, isActionCreator, isAllOf, isAnyOf, isAsyncThunkAction, isDraft6 as isDraft, isFSA as isFluxStandardAction, isFulfilled, isImmutableDefault, isPending, isPlain, isRejected, isRejectedWithValue, lruMemoize, miniSerializeError, nanoid, original2 as original, prepareAutoBatched, removeListener, unwrapResult, weakMapMemoize2 as weakMapMemoize };","map":null,"metadata":{},"sourceType":"module"}