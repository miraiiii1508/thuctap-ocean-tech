{"ast":null,"code":"import _assertThisInitialized from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/wrapNativeSuper\";\nimport _classCallCheck from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"D:\\\\ThucTap\\\\ThucTap\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return a;\n}; // src/utils/env.ts\n\n\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\"); // src/utils/errors.ts\n\nvar errors = process.env.NODE_ENV !== \"production\" ? [// All error codes, starting by 0:\nfunction (plugin) {\n  return \"The plugin for '\".concat(plugin, \"' has not been loaded into Immer. To enable the plugin, import and call `enable\").concat(plugin, \"()` when initializing your application.\");\n}, function (thing) {\n  return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\".concat(thing, \"'\");\n}, \"This object has been frozen and should not be mutated\", function (data) {\n  return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n}, \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\", \"Immer forbids circular references\", \"The first or second argument to `produce` must be a function\", \"The third argument to `produce` must be a function or undefined\", \"First argument to `createDraft` must be a plain object, an array, or an immerable object\", \"First argument to `finishDraft` must be a draft returned by `createDraft`\", function (thing) {\n  return \"'current' expects a draft, got: \".concat(thing);\n}, \"Object.defineProperty() cannot be used on an Immer draft\", \"Object.setPrototypeOf() cannot be used on an Immer draft\", \"Immer only supports deleting array indices\", \"Immer only supports setting array indices and the 'length' property\", function (thing) {\n  return \"'original' expects a draft, got: \".concat(thing);\n} // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n// See Patches.ts for additional errors\n] : [];\n\nfunction die(error) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var e = errors[error];\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(\"[Immer] \".concat(msg));\n  }\n\n  throw new Error(\"[Immer] minified error nr: \".concat(error, \". Full error at: https://bit.ly/3cXEKWf\"));\n} // src/utils/common.ts\n\n\nvar _getPrototypeOf = Object.getPrototypeOf;\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n  var _a;\n\n  if (!value) return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap(value) || isSet(value);\n}\n\nvar objectCtorString = Object.prototype.constructor.toString();\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") return false;\n\n  var proto = _getPrototypeOf(value);\n\n  if (proto === null) {\n    return true;\n  }\n\n  var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object) return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\n\nfunction original(value) {\n  if (!isDraft(value)) die(15, value);\n  return value[DRAFT_STATE].base_;\n}\n\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0\n  /* Object */\n  ) {\n      Reflect.ownKeys(obj).forEach(function (key) {\n        iter(key, obj[key], obj);\n      });\n    } else {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  }\n}\n\nfunction getArchtype(thing) {\n  var state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1\n  /* Array */\n  : isMap(thing) ? 2\n  /* Map */\n  : isSet(thing) ? 3\n  /* Set */\n  : 0\n  /* Object */\n  ;\n}\n\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2\n  /* Map */\n  ? thing.get(prop) : thing[prop];\n}\n\nfunction set(thing, propOrOldValue, value) {\n  var t = getArchtype(thing);\n  if (t === 2\n  /* Map */\n  ) thing.set(propOrOldValue, value);else if (t === 3\n  /* Set */\n  ) {\n      thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\n\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction isMap(target) {\n  return target instanceof Map;\n}\n\nfunction isSet(target) {\n  return target instanceof Set;\n}\n\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\n\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n\n  if (isSet(base)) {\n    return new Set(base);\n  }\n\n  if (Array.isArray(base)) return Array.prototype.slice.call(base);\n  var isPlain = isPlainObject(base);\n\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    var descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    var keys = Reflect.ownKeys(descriptors);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var desc = descriptors[key];\n\n      if (desc.writable === false) {\n        desc.writable = true;\n        desc.configurable = true;\n      }\n\n      if (desc.get || desc.set) descriptors[key] = {\n        configurable: true,\n        writable: true,\n        // could live with !!desc.set as well here...\n        enumerable: desc.enumerable,\n        value: base[key]\n      };\n    }\n\n    return Object.create(_getPrototypeOf(base), descriptors);\n  } else {\n    var proto = _getPrototypeOf(base);\n\n    if (proto !== null && isPlain) {\n      return __spreadValues({}, base);\n    }\n\n    var obj = Object.create(proto);\n    return Object.assign(obj, base);\n  }\n}\n\nfunction freeze(obj) {\n  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n  if (deep) Object.entries(obj).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    return freeze(value, true);\n  });\n  return obj;\n}\n\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\n\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n} // src/utils/plugins.ts\n\n\nvar plugins = {};\n\nfunction getPlugin(pluginKey) {\n  var plugin = plugins[pluginKey];\n\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n\n  return plugin;\n}\n\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n} // src/core/scope.ts\n\n\nvar currentScope;\n\nfunction getCurrentScope() {\n  return currentScope;\n}\n\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_: parent_,\n    immer_: immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\n\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\n\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\n\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\n\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\n\nfunction revokeDraft(draft) {\n  var state = draft[DRAFT_STATE];\n  if (state.type_ === 0\n  /* Object */\n  || state.type_ === 1\n  /* Array */\n  ) state.revoke_();else state.revoked_ = true;\n} // src/core/finalize.ts\n\n\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  var baseDraft = scope.drafts_[0];\n  var isReplaced = result !== void 0 && result !== baseDraft;\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_) maybeFreeze(scope, result);\n    }\n\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n\n  revokeScope(scope);\n\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n\n  return result !== NOTHING ? result : void 0;\n}\n\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value)) return value;\n  var state = value[DRAFT_STATE];\n\n  if (!state) {\n    each(value, function (key, childValue) {\n      return finalizeProperty(rootScope, state, value, key, childValue, path);\n    });\n    return value;\n  }\n\n  if (state.scope_ !== rootScope) return value;\n\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    var result = state.copy_;\n    var resultEach = result;\n    var isSet2 = false;\n\n    if (state.type_ === 3\n    /* Set */\n    ) {\n        resultEach = new Set(result);\n        result.clear();\n        isSet2 = true;\n      }\n\n    each(resultEach, function (key, childValue) {\n      return finalizeProperty(rootScope, state, result, key, childValue, path, isSet2);\n    });\n    maybeFreeze(rootScope, result, false);\n\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n    }\n  }\n\n  return state.copy_;\n}\n\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if (process.env.NODE_ENV !== \"production\" && childValue === targetObject) die(5);\n\n  if (isDraft(childValue)) {\n    var path = rootPath && parentState && parentState.type_ !== 3\n    /* Set */\n    && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    var res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n\n    finalize(rootScope, childValue);\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop)) maybeFreeze(rootScope, childValue);\n  }\n}\n\nfunction maybeFreeze(scope, value) {\n  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n} // src/core/proxy.ts\n\n\nfunction createProxyProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var state = {\n    type_: isArray ? 1\n    /* Array */\n    : 0\n    /* Object */\n    ,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  var target = state;\n  var traps = objectTraps;\n\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n\n  var _Proxy$revocable = Proxy.revocable(target, traps),\n      revoke = _Proxy$revocable.revoke,\n      proxy = _Proxy$revocable.proxy;\n\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n    var source = latest(state);\n\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n\n    var value = source[prop];\n\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n\n    return value;\n  },\n  has: function has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set: function set(state, prop, value) {\n    var desc = getDescriptorFromProto(latest(state), prop);\n\n    if (desc == null ? void 0 : desc.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n\n    if (!state.modified_) {\n      var current2 = peek(latest(state), prop);\n      var currentState = current2 == null ? void 0 : current2[DRAFT_STATE];\n\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'\n    value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc) return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1\n      /* Array */\n      || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty: function defineProperty() {\n    die(11);\n  },\n  getPrototypeOf: function getPrototypeOf(state) {\n    return _getPrototypeOf(state.base_);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop))) die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (process.env.NODE_ENV !== \"production\" && prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var source = state ? latest(state) : draft;\n  return source[prop];\n}\n\nfunction readPropFromProto(state, source, prop) {\n  var _a;\n\n  var desc = getDescriptorFromProto(source, prop);\n  return desc ? \"value\" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the\n  // prototype, we should invoke it with the draft as context!\n  (_a = desc.get) == null ? void 0 : _a.call(state.draft_) : void 0;\n}\n\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source)) return void 0;\n\n  var proto = _getPrototypeOf(source);\n\n  while (proto) {\n    var desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc) return desc;\n    proto = _getPrototypeOf(proto);\n  }\n\n  return void 0;\n}\n\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);\n  }\n} // src/core/immerClass.ts\n\n\nvar Immer2 = /*#__PURE__*/function () {\n  function Immer2(config) {\n    var _this = this;\n\n    _classCallCheck(this, Immer2);\n\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n\n    this.produce = function (base, recipe, patchListener) {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        var defaultBase = recipe;\n        recipe = base;\n        var self = _this;\n        return function curriedProduce() {\n          var _this2 = this;\n\n          var base2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;\n\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          return self.produce(base2, function (draft) {\n            var _recipe;\n\n            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));\n          });\n        };\n      }\n\n      if (typeof recipe !== \"function\") die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\") die(7);\n      var result;\n\n      if (isDraftable(base)) {\n        var scope = enterScope(_this);\n        var proxy = createProxy(base, void 0);\n        var hasError = true;\n\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError) revokeScope(scope);else leaveScope(scope);\n        }\n\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0) result = base;\n        if (result === NOTHING) result = void 0;\n        if (_this.autoFreeze_) freeze(result, true);\n\n        if (patchListener) {\n          var p = [];\n          var ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n\n        return result;\n      } else die(1, base);\n    };\n\n    this.produceWithPatches = function (base, recipe) {\n      if (typeof base === \"function\") {\n        return function (state) {\n          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n            args[_key3 - 1] = arguments[_key3];\n          }\n\n          return _this.produceWithPatches(state, function (draft) {\n            return base.apply(void 0, [draft].concat(args));\n          });\n        };\n      }\n\n      var patches, inversePatches;\n\n      var result = _this.produce(base, recipe, function (p, ip) {\n        patches = p;\n        inversePatches = ip;\n      });\n\n      return [result, patches, inversePatches];\n    };\n\n    if (typeof (config == null ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n    if (typeof (config == null ? void 0 : config.useStrictShallowCopy) === \"boolean\") this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n\n  _createClass(Immer2, [{\n    key: \"createDraft\",\n    value: function createDraft(base) {\n      if (!isDraftable(base)) die(8);\n      if (isDraft(base)) base = current(base);\n      var scope = enterScope(this);\n      var proxy = createProxy(base, void 0);\n      proxy[DRAFT_STATE].isManual_ = true;\n      leaveScope(scope);\n      return proxy;\n    }\n  }, {\n    key: \"finishDraft\",\n    value: function finishDraft(draft, patchListener) {\n      var state = draft && draft[DRAFT_STATE];\n      if (!state || !state.isManual_) die(9);\n      var scope = state.scope_;\n      usePatchesInScope(scope, patchListener);\n      return processResult(void 0, scope);\n    }\n    /**\n     * Pass true to automatically freeze all copies created by Immer.\n     *\n     * By default, auto-freezing is enabled.\n     */\n\n  }, {\n    key: \"setAutoFreeze\",\n    value: function setAutoFreeze(value) {\n      this.autoFreeze_ = value;\n    }\n    /**\n     * Pass true to enable strict shallow copy.\n     *\n     * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n     */\n\n  }, {\n    key: \"setUseStrictShallowCopy\",\n    value: function setUseStrictShallowCopy(value) {\n      this.useStrictShallowCopy_ = value;\n    }\n  }, {\n    key: \"applyPatches\",\n    value: function applyPatches(base, patches) {\n      var i;\n\n      for (i = patches.length - 1; i >= 0; i--) {\n        var patch = patches[i];\n\n        if (patch.path.length === 0 && patch.op === \"replace\") {\n          base = patch.value;\n          break;\n        }\n      }\n\n      if (i > -1) {\n        patches = patches.slice(i + 1);\n      }\n\n      var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n\n      if (isDraft(base)) {\n        return applyPatchesImpl(base, patches);\n      }\n\n      return this.produce(base, function (draft) {\n        return applyPatchesImpl(draft, patches);\n      });\n    }\n  }]);\n\n  return Immer2;\n}();\n\nfunction createProxy(value, parent) {\n  var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  var scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n} // src/core/current.ts\n\n\nfunction current(value) {\n  if (!isDraft(value)) die(10, value);\n  return currentImpl(value);\n}\n\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value)) return value;\n  var state = value[DRAFT_STATE];\n  var copy;\n\n  if (state) {\n    if (!state.modified_) return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n\n  each(copy, function (key, childValue) {\n    set(copy, key, currentImpl(childValue));\n  });\n\n  if (state) {\n    state.finalized_ = false;\n  }\n\n  return copy;\n} // src/plugins/patches.ts\n\n\nfunction enablePatches() {\n  var errorOffset = 16;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    errors.push('Sets cannot have \"replace\" patches.', function (op) {\n      return \"Unsupported patch operation: \" + op;\n    }, function (path) {\n      return \"Cannot apply patch, path doesn't resolve: \" + path;\n    }, \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\");\n  }\n\n  var REPLACE = \"replace\";\n  var ADD = \"add\";\n  var REMOVE = \"remove\";\n\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0\n      /* Object */\n      :\n      case 2\n      /* Map */\n      :\n        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n\n      case 1\n      /* Array */\n      :\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n\n      case 3\n      /* Set */\n      :\n        return generateSetPatches(state, basePath, patches, inversePatches);\n    }\n  }\n\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        assigned_ = state.assigned_;\n    var copy_ = state.copy_;\n\n    if (copy_.length < base_.length) {\n      ;\n      var _ref3 = [copy_, base_];\n      base_ = _ref3[0];\n      copy_ = _ref3[1];\n      var _ref4 = [inversePatches, patches];\n      patches = _ref4[0];\n      inversePatches = _ref4[1];\n    }\n\n    for (var i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path: path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path: path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n\n    for (var _i = base_.length; _i < copy_.length; _i++) {\n      var _path = basePath.concat([_i]);\n\n      patches.push({\n        op: ADD,\n        path: _path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[_i])\n      });\n    }\n\n    for (var _i2 = copy_.length - 1; base_.length <= _i2; --_i2) {\n      var _path2 = basePath.concat([_i2]);\n\n      inversePatches.push({\n        op: REMOVE,\n        path: _path2\n      });\n    }\n  }\n\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        copy_ = state.copy_;\n    each(state.assigned_, function (key, assignedValue) {\n      var origValue = get(base_, key);\n      var value = get(copy_, key);\n      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE) return;\n      var path = basePath.concat(key);\n      patches.push(op === REMOVE ? {\n        op: op,\n        path: path\n      } : {\n        op: op,\n        path: path,\n        value: value\n      });\n      inversePatches.push(op === ADD ? {\n        op: REMOVE,\n        path: path\n      } : op === REMOVE ? {\n        op: ADD,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      } : {\n        op: REPLACE,\n        path: path,\n        value: clonePatchValueIfNeeded(origValue)\n      });\n    });\n  }\n\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    var base_ = state.base_,\n        copy_ = state.copy_;\n    var i = 0;\n    base_.forEach(function (value) {\n      if (!copy_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path: path,\n          value: value\n        });\n      }\n\n      i++;\n    });\n    i = 0;\n    copy_.forEach(function (value) {\n      if (!base_.has(value)) {\n        var path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path: path,\n          value: value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path: path,\n          value: value\n        });\n      }\n\n      i++;\n    });\n  }\n\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n\n  function applyPatches_(draft, patches) {\n    patches.forEach(function (patch) {\n      var path = patch.path,\n          op = patch.op;\n      var base = draft;\n\n      for (var i = 0; i < path.length - 1; i++) {\n        var parentType = getArchtype(base);\n        var p = path[i];\n\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n\n        if ((parentType === 0\n        /* Object */\n        || parentType === 1\n        /* Array */\n        ) && (p === \"__proto__\" || p === \"constructor\")) die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\") die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"));\n      }\n\n      var type = getArchtype(base);\n      var value = deepClonePatchValue(patch.value);\n      var key = path[path.length - 1];\n\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              die(errorOffset);\n\n            default:\n              return base[key] = value;\n          }\n\n        case ADD:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n\n            case 2\n            /* Map */\n            :\n              return base.set(key, value);\n\n            case 3\n            /* Set */\n            :\n              return base.add(value);\n\n            default:\n              return base[key] = value;\n          }\n\n        case REMOVE:\n          switch (type) {\n            case 1\n            /* Array */\n            :\n              return base.splice(key, 1);\n\n            case 2\n            /* Map */\n            :\n              return base.delete(key);\n\n            case 3\n            /* Set */\n            :\n              return base.delete(patch.value);\n\n            default:\n              return delete base[key];\n          }\n\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj)) return obj;\n    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      return [k, deepClonePatchValue(v)];\n    }));\n    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n    var cloned = Object.create(_getPrototypeOf(obj));\n\n    for (var key in obj) {\n      cloned[key] = deepClonePatchValue(obj[key]);\n    }\n\n    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else return obj;\n  }\n\n  loadPlugin(\"Patches\", {\n    applyPatches_: applyPatches_,\n    generatePatches_: generatePatches_,\n    generateReplacementPatches_: generateReplacementPatches_\n  });\n} // src/plugins/mapset.ts\n\n\nfunction enableMapSet() {\n  var DraftMap = /*#__PURE__*/function (_Map) {\n    _inherits(DraftMap, _Map);\n\n    var _super = _createSuper(DraftMap);\n\n    function DraftMap(target, parent) {\n      var _this3;\n\n      _classCallCheck(this, DraftMap);\n\n      _this3 = _super.call(this);\n      _this3[DRAFT_STATE] = {\n        type_: 2\n        /* Map */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: _assertThisInitialized(_this3),\n        isManual_: false,\n        revoked_: false\n      };\n      return _this3;\n    }\n\n    _createClass(DraftMap, [{\n      key: \"size\",\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      }\n    }, {\n      key: \"has\",\n      value: function has(key) {\n        return latest(this[DRAFT_STATE]).has(key);\n      }\n    }, {\n      key: \"set\",\n      value: function set(key, value) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n\n        if (!latest(state).has(key) || latest(state).get(key) !== value) {\n          prepareMapCopy(state);\n          markChanged(state);\n          state.assigned_.set(key, true);\n          state.copy_.set(key, value);\n          state.assigned_.set(key, true);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(key) {\n        if (!this.has(key)) {\n          return false;\n        }\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareMapCopy(state);\n        markChanged(state);\n\n        if (state.base_.has(key)) {\n          state.assigned_.set(key, false);\n        } else {\n          state.assigned_.delete(key);\n        }\n\n        state.copy_.delete(key);\n        return true;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n\n        if (latest(state).size) {\n          prepareMapCopy(state);\n          markChanged(state);\n          state.assigned_ = /* @__PURE__ */new Map();\n          each(state.base_, function (key) {\n            state.assigned_.set(key, false);\n          });\n          state.copy_.clear();\n        }\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(cb, thisArg) {\n        var _this4 = this;\n\n        var state = this[DRAFT_STATE];\n        latest(state).forEach(function (_value, key, _map) {\n          cb.call(thisArg, _this4.get(key), key, _this4);\n        });\n      }\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        var value = latest(state).get(key);\n\n        if (state.finalized_ || !isDraftable(value)) {\n          return value;\n        }\n\n        if (value !== state.base_.get(key)) {\n          return value;\n        }\n\n        var draft = createProxy(value, state);\n        prepareMapCopy(state);\n        state.copy_.set(key, draft);\n        return draft;\n      }\n    }, {\n      key: \"keys\",\n      value: function keys() {\n        return latest(this[DRAFT_STATE]).keys();\n      }\n    }, {\n      key: \"values\",\n      value: function values() {\n        var _this5 = this;\n\n        var iterator = this.keys();\n        return {\n          [Symbol.iterator]: function () {\n            return _this5.values();\n          },\n          next: function next() {\n            var r = iterator.next();\n            if (r.done) return r;\n\n            var value = _this5.get(r.value);\n\n            return {\n              done: false,\n              value: value\n            };\n          }\n        };\n      }\n    }, {\n      key: \"entries\",\n      value: function entries() {\n        var _this6 = this;\n\n        var iterator = this.keys();\n        return {\n          [Symbol.iterator]: function () {\n            return _this6.entries();\n          },\n          next: function next() {\n            var r = iterator.next();\n            if (r.done) return r;\n\n            var value = _this6.get(r.value);\n\n            return {\n              done: false,\n              value: [r.value, value]\n            };\n          }\n        };\n      }\n    }, {\n      key: (DRAFT_STATE, Symbol.iterator),\n      value: function value() {\n        return this.entries();\n      }\n    }]);\n\n    return DraftMap;\n  }( /*#__PURE__*/_wrapNativeSuper(Map));\n\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n\n  var DraftSet = /*#__PURE__*/function (_Set) {\n    _inherits(DraftSet, _Set);\n\n    var _super2 = _createSuper(DraftSet);\n\n    function DraftSet(target, parent) {\n      var _this7;\n\n      _classCallCheck(this, DraftSet);\n\n      _this7 = _super2.call(this);\n      _this7[DRAFT_STATE] = {\n        type_: 3\n        /* Set */\n        ,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: _assertThisInitialized(_this7),\n        drafts_: /* @__PURE__ */new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n      return _this7;\n    }\n\n    _createClass(DraftSet, [{\n      key: \"size\",\n      get: function get() {\n        return latest(this[DRAFT_STATE]).size;\n      }\n    }, {\n      key: \"has\",\n      value: function has(value) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n\n        if (!state.copy_) {\n          return state.base_.has(value);\n        }\n\n        if (state.copy_.has(value)) return true;\n        if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n        return false;\n      }\n    }, {\n      key: \"add\",\n      value: function add(value) {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n\n        if (!this.has(value)) {\n          prepareSetCopy(state);\n          markChanged(state);\n          state.copy_.add(value);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(value) {\n        if (!this.has(value)) {\n          return false;\n        }\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareSetCopy(state);\n        markChanged(state);\n        return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :\n        /* istanbul ignore next */\n        false);\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n\n        if (latest(state).size) {\n          prepareSetCopy(state);\n          markChanged(state);\n          state.copy_.clear();\n        }\n      }\n    }, {\n      key: \"values\",\n      value: function values() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareSetCopy(state);\n        return state.copy_.values();\n      }\n    }, {\n      key: \"entries\",\n      value: function entries() {\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        prepareSetCopy(state);\n        return state.copy_.entries();\n      }\n    }, {\n      key: \"keys\",\n      value: function keys() {\n        return this.values();\n      }\n    }, {\n      key: (DRAFT_STATE, Symbol.iterator),\n      value: function value() {\n        return this.values();\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(cb, thisArg) {\n        var iterator = this.values();\n        var result = iterator.next();\n\n        while (!result.done) {\n          cb.call(thisArg, result.value, result.value, this);\n          result = iterator.next();\n        }\n      }\n    }]);\n\n    return DraftSet;\n  }( /*#__PURE__*/_wrapNativeSuper(Set));\n\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */new Set();\n      state.base_.forEach(function (value) {\n        if (isDraftable(value)) {\n          var draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n\n  function assertUnrevoked(state) {\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\n  }\n\n  loadPlugin(\"MapSet\", {\n    proxyMap_: proxyMap_,\n    proxySet_: proxySet_\n  });\n} // src/immer.ts\n\n\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\n\nfunction castDraft(value) {\n  return value;\n}\n\nfunction castImmutable(value) {\n  return value;\n}\n\nexport { Immer2 as Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableMapSet, enablePatches, finishDraft, freeze, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseStrictShallowCopy };","map":null,"metadata":{},"sourceType":"module"}